<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>crossPQW</title>
  <meta name="viewport" content="width=device-width">
  <meta property="og:type" content="website">
<meta property="og:title" content="crossPQW">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="crossPQW">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="crossPQW">
  
    <link rel="alternative" href="/atom.xml" title="crossPQW" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div class="mobile-nav-panel">
	<i class="icon-reorder icon-large"></i>
</div>
<header id="header">
	<h1 class="blog-title">
		<a href="/">crossPQW</a>
	</h1>
	<nav class="nav">
		<ul>
			<li><a href="/">Home</a></li><li><a href="/archives">Archives</a></li>
			<li><a id="nav-search-btn" class="nav-icon" title="Search"></a></li>
			<li><a href="/atom.xml" id="nav-rss-link" class="nav-icon" title="RSS Feed"></a></li>
		</ul>
	</nav>
	<div id="search-form-wrap">
		<form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
	</div>
</header>
    <div id="main">
      
  
    <article id="post-通过file&#39;s owner构建可在sb中使用的xib" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2016/01/08/通过file's owner构建可在sb中使用的xib/" class="article-date">
  <time datetime="2016-01-08T02:23:34.000Z" itemprop="datePublished">2016-01-08</time>
</a>
		</span>
		<span class="meta-elements author">黄少华</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2016/01/08/通过file's owner构建可在sb中使用的xib/">通过file&#39;s owner构建可在sb中使用的xib</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<p>首先上<a href="https://github.com/crossPQW/useXibInSb/tree/master" target="_blank" rel="noopener">源码github地址</a></p>
<p>首先新建一个xib,命名为TestView.xib,一个class类名为TestView.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/290760-f1dbad5a6c043dca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.jpg"><br>然后简单的在xib中添加一个背景图,一个UILabel用来展示,并且设置好约束.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/290760-515322947dcfd425.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.jpg"><br>常规我们使用xib的话通常会把TestView.swift类绑定为这个xib,为了能够在其他的storyboard中我们换一种方式,指定xib的file’s owner为该类,这样的话我们还可以在storyboard中像view controller构建的xib那样拖线了,而viewcontroller正是其内部view的file’s owner,这里的思路正是借鉴了这个.</p>
<p>选中file’s owner选项在右边面板里面绑定为自定义的xib.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/290760-c3ebb7c17fbd90a9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.jpg"><br>下面则是关键部分了,为了能够在storyboard中以及正常我们通过init方法初始化的时候正常使用这个xib,我们需要复写两个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init(frame: CGRect)</span><br><span class="line">init?(coder aDecoder: NSCoder)</span><br></pre></td></tr></table></figure>
<p>正常我们使用init构造方法初始化的时候,会调用<code>init(frame: CGRect)</code>,而xib跟storyboard的本质是xml文件,所以往下会调用<code>init?(coder aDecoder: NSCoder)</code>方法.</p>
<p>在这两个方法中实现setup()方法即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func setup()&#123;</span><br><span class="line">    </span><br><span class="line">    let bundle = NSBundle(forClass: self.dynamicType)</span><br><span class="line">    let nib    = UINib(nibName: &quot;TestView&quot;, bundle: bundle)</span><br><span class="line">    </span><br><span class="line">    view = nib.instantiateWithOwner(self, options: nil)[0] as! UIView</span><br><span class="line">    </span><br><span class="line">    view.frame = bounds</span><br><span class="line">            </span><br><span class="line">    addSubview(view)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们在storyboard中随便拖一个view,只要指定这个view的Class为TestView即可.    </p>
<p><img src="http://upload-images.jianshu.io/upload_images/290760-2be3f10dc5381164.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.jpg"><br>除此之外,并不需要在storyboard中做任何操作,运行之后,OK,正是我们想要的效果.   </p>
<p><img src="http://upload-images.jianshu.io/upload_images/290760-dafb9a543a0ddede.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.jpg">  </p>
<p>#####Extension:我们还使用<code>@IBInspectable</code>对xib进行可视化编辑<br>我们先把背景图与文字拖为属性,然后使用<code>@IBInspectable</code>设置其get与set方法即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@IBOutlet weak var bgimage: UIImageView!</span><br><span class="line"></span><br><span class="line">@IBOutlet weak var topicTitle: UILabel!</span><br><span class="line"></span><br><span class="line">@IBInspectable var backgroundImage :UIImage&#123;</span><br><span class="line">    get&#123;</span><br><span class="line">        return bgimage.image!</span><br><span class="line">    &#125;</span><br><span class="line">    set&#123;</span><br><span class="line">        bgimage.image = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@IBInspectable var title: NSString&#123;</span><br><span class="line">    get&#123;</span><br><span class="line">        return topicTitle.text!</span><br><span class="line">    &#125;</span><br><span class="line">    set&#123;</span><br><span class="line">        topicTitle.text = newValue as String</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>OK,这里我们再通过storyboard中使用的时候就更方便了,直接进行属性的设置<br>如图:  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/290760-25444248ada99b06.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.jpg"></p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-swift的导入过程" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2016/01/01/swift的导入过程/" class="article-date">
  <time datetime="2016-01-01T01:45:45.000Z" itemprop="datePublished">2016-01-01</time>
</a>
		</span>
		<span class="meta-elements author">黄少华</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2016/01/01/swift的导入过程/">swift的导入过程</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<p>当我们新建一个xcode项目之后,我们可以在Swift里面导入任意Objective-C的Cocoa平台框架.</p>
<p>任意Objective-C的框架或者一些C的类库将会作为一个<code>module(模块)</code>,直接导入到swift中,包括了所有的Objective-C系统的框架比如<code>Foundation</code>,<code>UIKit</code>还有<code>SpriteKit</code>等,就像系统支持公共的C类库.煮个栗子:如果我们想导入<code>Foundation</code>,只需要简单的添加import语句到我们写的Swift文件的顶部.</p>
<pre><code>import Foundation //需要注意的是,swift没有头文件,实现与接口之间没有明显的划分,所以一个类中所有信息全部都存储在单独的.swift文件当中.
</code></pre><p>这个import导入了所有Foundation的API,包括NSDate,NSURL,NSMutableDate,并且他们中所有的方法,属性和分类都可以在swift中直接调用.</p>
<p>Objective-C(以下简称OC)在头文件里面声明API,而在swift中,这些头文件被编译成了OC中得<code>module</code>,然后被导入到swift中作为swift的API,导入决定了OC得<code>Function,class,Method</code>和<code>type</code>如何在swift中出现,对于<code>Function</code>和<code>Method</code>,这个过程影响他们的参数以及返回值.在导入的过程中可以做以下事情:</p>
<ol>
<li>重映射确定的OC类型到swift中得同等类型,就想id到AnyObject.</li>
<li>重映射确定的OC核心类型到swift中得替代类型,比如NSString到String.</li>
<li>重映射确定的OC概念到swift中相对应的概念,比如pointers到optionals.</li>
</ol>
<p><em>参考资料:The Swift Programming Language</em></p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-objective-C内存管理学习笔记" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/12/30/objective-C内存管理学习笔记/" class="article-date">
  <time datetime="2015-12-30T01:20:40.000Z" itemprop="datePublished">2015-12-30</time>
</a>
		</span>
		<span class="meta-elements author">黄少华</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2015/12/30/objective-C内存管理学习笔记/">objective-C内存管理学习笔记</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<blockquote>
<p>Pro Multithreading and Memory Management for iOS and OS X是iOS与OSX平台开发者的神书之一不解释,适合时常翻阅,虽然说ARC时代对于内存管理开发者不需要过多的参与,编译器帮我们做了绝大多数工作,但是适当的理解还是非常有必要的,我自己也遇到过一些诡异的bug是因为内存管理不当造成的,同时感觉内存管理这块也是面试时候的重点哈哈哈哈所以有必要深入了解一下.<br>这本书分三章:内存管理,Block,GCD,花了一段时间把内存管理篇读完了,写点总结权当巩固一下知识.</p>
</blockquote>
<p>###1.引用计数<br>不同于java等语言的垃圾回收机制,苹果引入了引用计数的改变,简单的理解就是一个对象被人持有的时候,引用计数retainCount + 1,这个引用关系没有的时候就-1,当引用计数为0的时候则认为对象没有被人持有,就释放掉这个对象了.一般当我们调用<code>alloc,new,copy,mutableCopy</code>开头的方法的时候我们自己都会持有这个对象,自己可以持有自己生成的对象,同时也能够持有别人生成的对象,比如:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//obj持有自己生成的对象</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">//obj2持有obj这个对象</span><br><span class="line">id obj2 = obj;</span><br></pre></td></tr></table></figure>
<p>###2.ARC 自动引入计数<br>顾名思义,自动引用计数(相对于MRC手动引用计数),是Xcode的编译器特性之一,编译器会在适当的时候帮我们插入内存管理代码(不是这么简单还有其他一些复杂的优化操作),让我们避免了花费大量精力去考虑内存管理.<br>先了解一下对象的所有权修饰符,在ARC环境下,有四种所有权修饰符:  </p>
<ol>
<li><code>__strong</code></li>
<li><code>__weak</code>  </li>
<li><code>__unsa__unretained</code>  </li>
<li><code>__autorelease</code>  </li>
</ol>
<p>我们平时这样定义一个属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, strong) UIView *view;</span><br></pre></td></tr></table></figure></p>
<p>其中的strong就是内存管理关键字,实际上我们在定义属性的时候使用的strong/weak/assign等都是被转化成这些修饰符,下面是对应的转化关系:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assign            ------&gt; __unsafe__unretained修饰符</span><br><span class="line">copy              ------&gt; __strong修饰符(赋值的是被复制的变量)</span><br><span class="line">retain            ------&gt; __strong修饰符</span><br><span class="line">strong            ------&gt; __strong修饰符</span><br><span class="line">unsafe_unretained ------&gt; __unsafe__unretained修饰符</span><br><span class="line">weak              ------&gt; __weak修饰符</span><br></pre></td></tr></table></figure></p>
<p>使用以上关键字就相当于直接给属性加上了对应的修饰符,copy除外,copy赋值是通过<code>copyWithZone:</code>方法复制源对象的修饰符.</p>
<p>####2.1  <code>__strong</code>修饰符<br><code>__strong</code>是强引用的意思,它是id类型跟对象类型的默认修饰符,也就是说默认会加上<code>__strong</code>修饰符,除非你去显式的指定<code>__weak</code>等修饰符,这种修饰符修饰的对象会在超出它的作用域的时候释放掉,或者说如果是通过另外一个强引用对象赋值产生的强引用,会在它引用的对象为nil的时候释放掉.<br><code>__strong,__weak,__autoreleasing</code>这三种修饰符可以保证对象在初始化的时候把对象初始化为nil,这一点是跟<code>__unsafe__retained</code>很大的不同.  </p>
<p>####2.2  <code>__weak</code>修饰符<br><code>id __weak obj = [[NSObject alloc] init]</code><br><code>__weak</code>是iOS5之后新增的,即为弱引用,它是为了解决<code>__strong</code>修饰符导致循环引用来引入的,所谓循环引用就是A,B对象相互引用,就很容易发生了内存泄露,当然还有更罕见的A对象自己持有自己导致的循环引用.<br>弱引用不能持有一个实例对象,刚才的那句代码对象会立即释放,因为弱引用不持有对象,所以在对象超过作用域的时候就会立刻把对象释放掉,于是就打破了引用循环.<br>weak还有一个好处,当一个对象释放掉的时候,会立刻把对象置nil(assign对应的修饰符是<code>__unsafe__unretained</code>则不会).<br><em>weak实现</em><br>__weak修饰符的实现其实比较复杂,当我们初始化一个weak修饰的对象,运行时是调用<code>objc_initWeak(&amp;obj1,obj)</code>,<code>obj1</code>是我们初始化对象后赋值的对象,<code>obj</code>则是该对象本身,这个函数会继续调用<code>objc_storeWeak(&amp;obj1,
obj)</code>函数,然后把第二参数obj作为key,第一参数&amp;obj1作为value存储到weak表中,这样的话在废弃对象的时候通过将要废弃的对象的地址作为键值从表中查询就能够快速的查找到对应的对象了.<br><em>weak销毁</em><br>然后在对象作用域结束,就调用了销毁函数<code>objc_destoryWeak(&amp;obj1)</code>,这个函数具体会做哪些事呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1). objc_release  </span><br><span class="line">(2). 引用计数为0,执行dealloc  </span><br><span class="line">(3). _objc_roowDealloc</span><br><span class="line">(4). object_dispose  </span><br><span class="line">(5). objc_destructInstance  </span><br><span class="line">(6). objc_clear_deallocating</span><br></pre></td></tr></table></figure></p>
<p>其中最后一个函数<code>objc_clear_deallocating</code>又会做以下操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. 从weak表中通过废弃对象的内存地址查找记录  </span><br><span class="line">b. 将查找到的所有__weak修饰的记录的地址赋值为nil.  </span><br><span class="line">c. 从weak表删除记录  </span><br><span class="line">d. 通过废弃对象的地址从引用计数表中查找到记录并且删除.</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到,通过这些操作,__weak修饰的对象在销毁的时候就能赋值为nil了,但是同时我们也应该看到使用weak是比较消耗cpu资源的,所以我们应该避免过多使用weak,而仅仅使用它来避免循环引用,这也是实现weak的目的所在.</p>
<p>####2.3 <code>__unsafa__unretained</code>修饰符<br>这玩意可以翻译为不安全不持有的修饰符,反正我是开发工作中是没有接触到过,它跟weak相同的是都不持有对象,所以生成的对象会立刻被释放掉.  </p>
<p>####2.4 <code>__autoreleasing</code>修饰符<br>在ARC下不能用<code>NSAutoreleasePool</code>来创建自动释放池,可以通过@autoreleasepool(没错就是程序入口的那玩意)来创建,使用了这个修饰符类似于在MRC下调用了<code>autorelease</code>方法.<br>还记得我们开头说的调用<code>alloc,new,copy,mutableCopy</code>方法会持有生成的对象么?那么当我们不是通过这些方法创建的对象呢?比如:  </p>
<pre><code>id obj = [NSArray array];
</code></pre><p>事实是如果编译器检查到对象不是通过以上四个方法创建的,会自动把这个对象注册到<code>autoreleasepool</code>,那么自动释放池里面的对象会什么时候释放呢?这里其实牵扯到runloop的知识,自动释放池会注册到runloop中,可以把runloop理解为一个不停<code>开始-休眠-开始</code>的循环,当本次循环执行完毕,下次循环开始的时候如果检测到对象没被引用就会释放这个对象(更多runloop相关内容可以看百度知道团队的runloop视频).<br>再回到weak,其实在访问<code>__weak</code>修饰的对象的时候,实际上必定会访问注册到<code>autoreleasepool</code>的对象.这句话怎么理解呢?<br>因为weak是弱引用,所以在访问的时候有可能对象已经被废弃了,所以苹果的做法是通过把要访问的对象注册到<code>autoreleasepool</code>中,在<code>@autoreleasepool{}</code>结束之前都能确保对象一直存在咯.  </p>
<blockquote>
<p>以上是自己读书下来的一些笔记,大致大致总结了一下各种关键字底层做了些什么,有错误的地方欢迎指出,后续再有新的心得会在这个博客下面继续记录下来~~</p>
</blockquote>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-读码笔记-YYWebImage源码 (三) -YYImageCache" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/12/16/读码笔记-YYWebImage源码 (三) -YYImageCache/" class="article-date">
  <time datetime="2015-12-16T12:20:00.000Z" itemprop="datePublished">2015-12-16</time>
</a>
		</span>
		<span class="meta-elements author">黄少华</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2015/12/16/读码笔记-YYWebImage源码 (三) -YYImageCache/">读码笔记-YYWebImage源码 (三) -YYImageCache</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<blockquote>
<p>这个类内容比较简单,api也都 通俗易懂,仅仅把注释贴上来即可,深究为什么这么简单,其实还是因为这个类做的事情其实仅仅是统一的调用<code>YYMemoryCache,YYMemoryCache</code>来存取图片而已,具体的存储细节都实现在<code>YYCache里面了</code>,所以这里使用起来才会简单轻松.</p>
</blockquote>
<p>先看开放了哪些api,都是什么意思<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">///图片缓存类型</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, YYImageCacheType) &#123;</span><br><span class="line">    /// No value.</span><br><span class="line">    YYImageCacheTypeNone   = 0,</span><br><span class="line">    </span><br><span class="line">    /// Get/store image with memory cache.//从内存中获取</span><br><span class="line">    YYImageCacheTypeMemory = 1 &lt;&lt; 0,</span><br><span class="line">    </span><br><span class="line">    /// Get/store image with disk cache.//从磁盘中获取</span><br><span class="line">    YYImageCacheTypeDisk   = 1 &lt;&lt; 1,</span><br><span class="line">    </span><br><span class="line">    /// Get/store image with both memory cache and disk cache.//同时获取</span><br><span class="line">    YYImageCacheTypeAll    = YYImageCacheTypeMemory | YYImageCacheTypeDisk,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  YYImageCache是一个用来存储UIImage和image数据的缓存,是基于内存缓存与磁盘缓存实现的</span><br><span class="line"> </span><br><span class="line"> @discussion 磁盘缓存会尝试保护原始的图片数据</span><br><span class="line"> 如果原始的图片仍是image,会保存为一个png或者jpeg</span><br><span class="line"> 如果原始图片是一个gif,apng,webp动图,会保存为原始格式</span><br><span class="line"> 如果原始图片缩放比例不是1,那么缩放值会被保存为一个缩放的数据</span><br><span class="line"> 虽然图片能被NSCoding协议解码,但是这不是一个最优解:</span><br><span class="line"> 苹果的确使用UIImagePNGRepresentation()来解码所有类型的图片,但是可能会丢失原始的可变帧数据.结果就是打包成plist文件不能直接查看照片.如果图片没有alpha通道,使用JPEG代理PNG能够保存更多的尺寸和编解码时间.</span><br><span class="line"> */</span><br><span class="line">@interface YYImageCache : NSObject</span><br><span class="line"></span><br><span class="line">//缓存名字,默认为nil</span><br><span class="line">@property (copy) NSString *name;</span><br><span class="line"></span><br><span class="line">//内存缓存,具体信息看YYMemoryCache</span><br><span class="line">@property (strong, readonly) YYMemoryCache *memoryCache;</span><br><span class="line"></span><br><span class="line">//磁盘缓存,具体信息看YYDiskCache</span><br><span class="line">@property (strong, readonly) YYDiskCache *diskCache;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  当从磁盘缓存请求图片的时候是否解码动图,默认为YES</span><br><span class="line"> @discussion 当从磁盘缓存读取图片,会使用YYImage来解码比如WebP/APNG/GIF格式的动图,设置这个值为NO可以忽略动图</span><br><span class="line"> */</span><br><span class="line">@property (assign) BOOL allowAnimatedImage;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  是否解码图片存储位图,默认为YES</span><br><span class="line"> @discussion 如果这个值为YES,图片会通过位图解码来获得更好的用户体验,但是可能会消耗更大的内存资源</span><br><span class="line"> */</span><br><span class="line">@property (assign) BOOL decodeForDisplay;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (instancetype)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">+ (instancetype)new UNAVAILABLE_ATTRIBUTE;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  单例类初始化方法</span><br><span class="line"> */</span><br><span class="line">+ (instancetype)sharedCache;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  初始化方法,在多个情况下访问同一个路径会导致缓存不稳定</span><br><span class="line"> *</span><br><span class="line"> *  @param path cache读写的全路径,只初始化一次,你不应该来读写这个路径</span><br><span class="line"> *</span><br><span class="line"> *  @return 一个新的缓存对象,或者返回带nil带error信息</span><br><span class="line"> */</span><br><span class="line">- (instancetype)initWithPath:(NSString *)path NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  把图片通过一个具体的key存进缓存,同时memory跟disk都会存,这个方法会立刻返回,在后台线程执行</span><br><span class="line"> *</span><br><span class="line"> *  @param image 如果为nil这个方法无效</span><br><span class="line"> *  @param key 存储图片的key,为nil这个方法无效</span><br><span class="line"> */</span><br><span class="line">- (void)setImage:(UIImage *)image forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  通过一个key把图片缓存,这个方法会立刻返回并在后台执行</span><br><span class="line">    如果&apos;type&apos;包括&apos;YYImageCacheTypeMemory&apos;,那么图片会被存进memory,如果image为nil会用&apos;imageData&apos;代理</span><br><span class="line">    如果&apos;type&apos;包括&apos;YYImageCacheTypeDisk&apos;,那么&apos;imageData&apos;会被存进磁盘缓存,如果&apos;imageData&apos;为nil会用image代替</span><br><span class="line"> //这里可以看到作者一个思想,如果存进memory,直接存image,会减小很多解码的消耗,如果存disk,会存imageData</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">- (void)setImage:(UIImage *)image imageData:(NSData *)imageData forKey:(NSString *)key withType:(YYImageCacheType)type;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  通过key移除cache中的一个图片,memory跟disk会同时移除</span><br><span class="line">    这个方法会立刻返回并在后台线程执行</span><br><span class="line"> *</span><br><span class="line"> *  @param key 移除图片用的key,为nil的话这个方法没啥用</span><br><span class="line"> */</span><br><span class="line">- (void)removeImageForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  从缓存中通过key删图片</span><br><span class="line"> 这个方法会立刻返回并在后台线程执行</span><br><span class="line"> *</span><br><span class="line"> *  @param key  key</span><br><span class="line"> *  @param type 从哪删除,跟上个方法不同,这个可以删除指定类型的缓存</span><br><span class="line"> */</span><br><span class="line">- (void)removeImageForKey:(NSString *)key withType:(YYImageCacheType)type;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  通过key检查缓存中是否有某个图片</span><br><span class="line">    如果图片不在内存中,这个方法可能会阻塞线程,知道这个文件读取完毕</span><br><span class="line"> *</span><br><span class="line"> *  @param key key,为nil时返回NO</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">- (BOOL)containsImageForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  跟上个差不多,只不过可以查具体类型的缓存</span><br><span class="line"> */</span><br><span class="line">- (BOOL)containsImageForKey:(NSString *)key withType:(YYImageCacheType)type;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  通过key获取图片,如果图片不在内存中,这个方法可能会阻塞线程知道文件读取完毕</span><br><span class="line"> *</span><br><span class="line"> *  @param key 一个字符串类型图片缓存key,为nil方法返回nil</span><br><span class="line"> *</span><br><span class="line"> *  @return 通过key查到的图片,没有图片就是nil</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)getImageForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  跟上个方法差不多,只不过从指定缓存类型中获取图片</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)getImageForKey:(NSString *)key withType:(YYImageCacheType)type;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  通过key异步的获取图片</span><br><span class="line"> *</span><br><span class="line"> *  @param key   key</span><br><span class="line"> *  @param type  缓存类型</span><br><span class="line"> *  @param block 完成的block回调,主线程调用的</span><br><span class="line"> */</span><br><span class="line">- (void)getImageForKey:(NSString *)key withType:(YYImageCacheType)type withBlock:(void(^)(UIImage *image, YYImageCacheType type))block;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  通过key查找图片数据data格式,方法会阻塞主线程知道文件读取完毕</span><br><span class="line"> *</span><br><span class="line"> *  @param key key</span><br><span class="line"> *</span><br><span class="line"> *  @return 图片数据,查不到为nil</span><br><span class="line"> */</span><br><span class="line">- (NSData *)getImageDataForKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  通过key来异步的获取图片数据</span><br><span class="line"> *</span><br><span class="line"> *  @param key   &lt;#key description#&gt;</span><br><span class="line"> *  @param block 主线程的完成回调</span><br><span class="line"> */</span><br><span class="line">- (void)getImageDataForKey:(NSString *)key withBlock:(void(^)(NSData *imageData))block;</span><br></pre></td></tr></table></figure></p>
<p>其实现细节如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static inline dispatch_queue_t YYImageCacheIOQueue() &#123;</span><br><span class="line">#ifdef YYDispatchQueuePool_h</span><br><span class="line">    return YYDispatchQueueGetForQOS(NSQualityOfServiceDefault);</span><br><span class="line">#else</span><br><span class="line">    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline dispatch_queue_t YYImageCacheDecodeQueue() &#123;</span><br><span class="line">#ifdef YYDispatchQueuePool_h</span><br><span class="line">    return YYDispatchQueueGetForQOS(NSQualityOfServiceUtility);</span><br><span class="line">#else</span><br><span class="line">    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface YYImageCache ()</span><br><span class="line">- (NSUInteger)imageCost:(UIImage *)image;</span><br><span class="line">- (UIImage *)imageFromData:(NSData *)data;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation YYImageCache</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  图片消耗</span><br><span class="line"> */</span><br><span class="line">- (NSUInteger)imageCost:(UIImage *)image &#123;</span><br><span class="line">    CGImageRef cgImage = image.CGImage;</span><br><span class="line">    if (!cgImage) return 1;</span><br><span class="line">    CGFloat height = CGImageGetHeight(cgImage);</span><br><span class="line">    size_t bytesPerRow = CGImageGetBytesPerRow(cgImage);</span><br><span class="line">    NSUInteger cost = bytesPerRow * height;</span><br><span class="line">    if (cost == 0) cost = 1;</span><br><span class="line">    return cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  通过data转换为image</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)imageFromData:(NSData *)data &#123;</span><br><span class="line">    NSData *scaleData = [YYDiskCache getExtendedDataFromObject:data];</span><br><span class="line">    CGFloat scale = 0;</span><br><span class="line">    if (scaleData) &#123;</span><br><span class="line">        scale = ((NSNumber *)[NSKeyedUnarchiver unarchiveObjectWithData:scaleData]).doubleValue;</span><br><span class="line">    &#125;</span><br><span class="line">    if (scale &lt;= 0) scale = [UIScreen mainScreen].scale;</span><br><span class="line">    UIImage *image;</span><br><span class="line">    if (_allowAnimatedImage) &#123;</span><br><span class="line">        image = [[YYImage alloc] initWithData:data scale:scale];</span><br><span class="line">        if (_decodeForDisplay) image = [image yy_imageByDecoded];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        YYImageDecoder *decoder = [YYImageDecoder decoderWithData:data scale:scale];</span><br><span class="line">        image = [decoder frameAtIndex:0 decodeForDisplay:_decodeForDisplay].image;</span><br><span class="line">    &#125;</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark Public</span><br><span class="line">/**</span><br><span class="line"> *  单例类的初始化方法</span><br><span class="line"> */</span><br><span class="line">+ (instancetype)sharedCache &#123;</span><br><span class="line">    static YYImageCache *cache = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        NSString *cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory,</span><br><span class="line">                                                                   NSUserDomainMask, YES) firstObject];</span><br><span class="line">        //拼接路径</span><br><span class="line">        cachePath = [cachePath stringByAppendingPathComponent:@&quot;com.ibireme.yykit&quot;];</span><br><span class="line">        cachePath = [cachePath stringByAppendingPathComponent:@&quot;images&quot;];</span><br><span class="line">        cache = [[self alloc] initWithPath:cachePath];</span><br><span class="line">    &#125;);</span><br><span class="line">    return cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;YYImageCache init error&quot; reason:@&quot;YYImageCache must be initialized with a path. Use &apos;initWithPath:&apos; instead.&quot; userInfo:nil];</span><br><span class="line">    return [self initWithPath:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  在初始化的时候同时初始化内存缓存跟磁盘缓存</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">- (instancetype)initWithPath:(NSString *)path &#123;</span><br><span class="line">    //在调用父类init之前先初始化一个内存缓存跟磁盘缓存</span><br><span class="line">    YYMemoryCache *memoryCache = [YYMemoryCache new];//生成内存缓存</span><br><span class="line">    memoryCache.shouldRemoveAllObjectsOnMemoryWarning = YES;//内存警告的时候删除所有内容</span><br><span class="line">    memoryCache.shouldRemoveAllObjectsWhenEnteringBackground = YES;//进入后台删除所有内容</span><br><span class="line">    memoryCache.countLimit = NSUIntegerMax;//不予限制</span><br><span class="line">    memoryCache.costLimit = NSUIntegerMax;//不予限制</span><br><span class="line">    memoryCache.ageLimit = 12 * 60 * 60;//cache存在的时间限制设置为12个小时</span><br><span class="line">    </span><br><span class="line">    YYDiskCache *diskCache = [[YYDiskCache alloc] initWithPath:path];//生成磁盘缓存</span><br><span class="line">    diskCache.customArchiveBlock = ^(id object) &#123; return (NSData *)object; &#125;;//自己来archive数据</span><br><span class="line">    diskCache.customUnarchiveBlock = ^(NSData *data) &#123; return (id)data; &#125;;//自己unarchive数据</span><br><span class="line">    if (!memoryCache || !diskCache) return nil;//如果有任意一个初始化失败,返回nil</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    _memoryCache = memoryCache;</span><br><span class="line">    _diskCache = diskCache;</span><br><span class="line">    _allowAnimatedImage = YES;</span><br><span class="line">    _decodeForDisplay = YES;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setImage:(UIImage *)image forKey:(NSString *)key &#123;</span><br><span class="line">    [self setImage:image imageData:nil forKey:key withType:YYImageCacheTypeAll];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setImage:(UIImage *)image imageData:(NSData *)imageData forKey:(NSString *)key withType:(YYImageCacheType)type &#123;</span><br><span class="line">    //在每一个方法执行前先检查参数的有效性,非常好的习惯</span><br><span class="line">    if (!key || (image == nil &amp;&amp; imageData.length == 0)) return;</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) _self = self;</span><br><span class="line">    //如果类型有YYImageCacheTypeMemory</span><br><span class="line">    if (type &amp; YYImageCacheTypeMemory) &#123; // add to memory cache</span><br><span class="line">        if (image) &#123;</span><br><span class="line">            if (image.yy_isDecodedForDisplay) &#123;</span><br><span class="line">                //开启了位图解码的话直接把图片丢进内存缓存里面咯</span><br><span class="line">                [_memoryCache setObject:image forKey:key withCost:[_self imageCost:image]];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //否则开启一个异步的解码队列,把图片转成位图,再丢进缓存里面</span><br><span class="line">                dispatch_async(YYImageCacheDecodeQueue(), ^&#123;</span><br><span class="line">                    __strong typeof(_self) self = _self;</span><br><span class="line">                    if (!self) return;</span><br><span class="line">                    [self.memoryCache setObject:[image yy_imageByDecoded] forKey:key withCost:[self imageCost:image]];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (imageData) &#123;//如果图片不存在,图片数据存在,那就通过data生成一个图片,丢进内存中存起来</span><br><span class="line">            dispatch_async(YYImageCacheDecodeQueue(), ^&#123;</span><br><span class="line">                __strong typeof(_self) self = _self;</span><br><span class="line">                if (!self) return;</span><br><span class="line">                UIImage *newImage = [self imageFromData:imageData];</span><br><span class="line">                [self.memoryCache setObject:[self imageFromData:imageData] forKey:key withCost:[self imageCost:newImage]];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果类型包含磁盘缓存,存进磁盘</span><br><span class="line">    if (type &amp; YYImageCacheTypeDisk) &#123; // add to disk cache</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                [YYDiskCache setExtendedData:[NSKeyedArchiver archivedDataWithRootObject:@(image.scale)] toObject:imageData];</span><br><span class="line">            &#125;</span><br><span class="line">            [_diskCache setObject:imageData forKey:key];</span><br><span class="line">        &#125; else if (image) &#123;</span><br><span class="line">            dispatch_async(YYImageCacheIOQueue(), ^&#123;</span><br><span class="line">                __strong typeof(_self) self = _self;</span><br><span class="line">                if (!self) return;</span><br><span class="line">                NSData *data = [image yy_imageDataRepresentation];</span><br><span class="line">                [YYDiskCache setExtendedData:[NSKeyedArchiver archivedDataWithRootObject:@(image.scale)] toObject:data];</span><br><span class="line">                [self.diskCache setObject:data forKey:key];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  全删咯</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">- (void)removeImageForKey:(NSString *)key &#123;</span><br><span class="line">    [self removeImageForKey:key withType:YYImageCacheTypeAll];</span><br><span class="line">&#125;</span><br><span class="line">//有哪个类型删哪个</span><br><span class="line">- (void)removeImageForKey:(NSString *)key withType:(YYImageCacheType)type &#123;</span><br><span class="line">    if (type &amp; YYImageCacheTypeMemory) [_memoryCache removeObjectForKey:key];</span><br><span class="line">    if (type &amp; YYImageCacheTypeDisk) [_diskCache removeObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)containsImageForKey:(NSString *)key &#123;</span><br><span class="line">    return [self containsImageForKey:key withType:YYImageCacheTypeAll];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)containsImageForKey:(NSString *)key withType:(YYImageCacheType)type &#123;</span><br><span class="line">    if (type &amp; YYImageCacheTypeMemory) &#123;</span><br><span class="line">        if ([_memoryCache containsObjectForKey:key]) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    if (type &amp; YYImageCacheTypeDisk) &#123;</span><br><span class="line">        if ([_diskCache containsObjectForKey:key]) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)getImageForKey:(NSString *)key &#123;</span><br><span class="line">    return [self getImageForKey:key withType:YYImageCacheTypeAll];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过key找图片,都比较简单</span><br><span class="line">- (UIImage *)getImageForKey:(NSString *)key withType:(YYImageCacheType)type &#123;</span><br><span class="line">    if (!key) return nil;</span><br><span class="line">    if (type &amp; YYImageCacheTypeMemory) &#123;</span><br><span class="line">        UIImage *image = [_memoryCache objectForKey:key];</span><br><span class="line">        if (image) return image;</span><br><span class="line">    &#125;</span><br><span class="line">    if (type &amp; YYImageCacheTypeDisk) &#123;</span><br><span class="line">        NSData *data = (id)[_diskCache objectForKey:key];</span><br><span class="line">        UIImage *image = [self imageFromData:data];</span><br><span class="line">        if (image &amp;&amp; (type &amp; YYImageCacheTypeMemory)) &#123;</span><br><span class="line">            [_memoryCache setObject:image forKey:key withCost:[self imageCost:image]];</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//跟上个方法类似,只不过把查询的结果通过block传递了回去</span><br><span class="line">- (void)getImageForKey:(NSString *)key withType:(YYImageCacheType)type withBlock:(void (^)(UIImage *image, YYImageCacheType type))block &#123;</span><br><span class="line">    if (!block) return;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        UIImage *image = nil;</span><br><span class="line">        </span><br><span class="line">        if (type &amp; YYImageCacheTypeMemory) &#123;</span><br><span class="line">            image = [_memoryCache objectForKey:key];</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    block(image, YYImageCacheTypeMemory);</span><br><span class="line">                &#125;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (type &amp; YYImageCacheTypeDisk) &#123;</span><br><span class="line">            NSData *data = (id)[_diskCache objectForKey:key];</span><br><span class="line">            image = [self imageFromData:data];</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                [_memoryCache setObject:image forKey:key];</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    block(image, YYImageCacheTypeDisk);</span><br><span class="line">                &#125;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            block(nil, YYImageCacheTypeNone);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSData *)getImageDataForKey:(NSString *)key &#123;</span><br><span class="line">    return (id)[_diskCache objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)getImageDataForKey:(NSString *)key withBlock:(void (^)(NSData *imageData))block &#123;</span><br><span class="line">    if (!block) return;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        NSData *data = (id)[_diskCache objectForKey:key];</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            block(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>PS:<br><a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="noopener">YYWebImage源码地址</a><br><a href="https://github.com/crossPQW/YYWebImage" target="_blank" rel="noopener">我fork下来添加注释的版本github地址</a></p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-读码笔记-YYWebImage源码 (二) -YYWebImageOperation" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/12/15/读码笔记-YYWebImage源码 (二) -YYWebImageOperation/" class="article-date">
  <time datetime="2015-12-15T02:14:59.000Z" itemprop="datePublished">2015-12-15</time>
</a>
		</span>
		<span class="meta-elements author">黄少华</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2015/12/15/读码笔记-YYWebImage源码 (二) -YYWebImageOperation/">读码笔记-YYWebImage源码 (二) -YYWebImageOperation.md</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<blockquote>
<p><code>YYWebImageOperation</code>是一个自定义operation类,继承自<code>NSOperation</code>,本类读完之后可以很清晰的了解到作者在管理下载队列的时候的想法,以及如何自定义一个operation.</p>
</blockquote>
<p>首先看暴露给我们的头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  YYWebImageOperation 类是NSOperation的子类,用来通过请求获取图片, </span><br><span class="line"> </span><br><span class="line">     @discussion 首先这个operation是异步的,你可以通过把operation添加到一个queue里面来让这个operation生效,或者直接调用&apos;start&apos;方法.当这个operation开始之后,将会做以下事情:</span><br><span class="line">     1.从cache获取 图片,如果取到了,就返回&apos;completion&apos;block,并把图片传入block.</span><br><span class="line">     2.通过图片URL开启一个请求,会通过&apos;progress&apos;参数来通知women图片下载的进度,并且如果在传入option的时候开启了progressive option,会在completionblock里面返回一个渐进显示的图片</span><br><span class="line">     3.通过&apos;transform&apos;block来处理图片</span><br><span class="line">     4.把图片丢到cache中并且在&apos;completion&apos;block返回</span><br><span class="line"> */</span><br><span class="line">@interface YYWebImageOperation : NSOperation</span><br><span class="line"></span><br><span class="line">//图片请求</span><br><span class="line">@property (nonatomic, strong, readonly) NSURLRequest *request;     ///&lt; The image URL request.</span><br><span class="line">//请求的相应结果</span><br><span class="line">@property (nonatomic, strong, readonly) NSURLResponse *response;   ///&lt; The response for request.</span><br><span class="line">//理解为下载图片模式,具体见YYWebImageManager</span><br><span class="line">@property (nonatomic, assign, readonly) YYWebImageOptions options; ///&lt; The operation&apos;s option.</span><br><span class="line">//缓存</span><br><span class="line">@property (nonatomic, strong, readonly) YYImageCache *cache;       ///&lt; The image cache.</span><br><span class="line">//缓存key</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *cacheKey;        ///&lt; The image cache key.</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  这个URL connection 是否是从 存储的认证里面授权查阅出来的.默认值为YES</span><br><span class="line">    @discussion 这个值是NSURLConnectionDelegate的方法-connectionShouldUseCredentialStorage:的返回值</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) BOOL shouldUseCredentialStorage;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  NSURLCredential类</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong) NSURLCredential *credential;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  构造方法,会创建并返回一个新的operation</span><br><span class="line">    你应该调用start方法来开启这个operation,或者把它加到一个operation queue</span><br><span class="line"> *</span><br><span class="line"> *  @param request    图片请求,不可为nil</span><br><span class="line"> *  @param options    下载模式</span><br><span class="line"> *  @param cache      图片缓存,传nil的话就禁用了缓存</span><br><span class="line"> *  @param cacheKey   缓存key,传nil禁用图片缓存</span><br><span class="line"> *  @param progress   下载进度block</span><br><span class="line"> *  @param transform  这个block会在图片下载完成之前调用来让你对图片进行一些预处理,传nil禁用</span><br><span class="line"> *  @param completion 图片下载完成后或者已经取消下载了调用</span><br><span class="line"> *</span><br><span class="line"> *  @return operation实例,出现错误的话就为nil</span><br><span class="line"> */</span><br><span class="line">- (instancetype)initWithRequest:(NSURLRequest *)request</span><br><span class="line">                        options:(YYWebImageOptions)options</span><br><span class="line">                          cache:(YYImageCache *)cache</span><br><span class="line">                       cacheKey:(NSString *)cacheKey</span><br><span class="line">                       progress:(YYWebImageProgressBlock)progress</span><br><span class="line">                      transform:(YYWebImageTransformBlock)transform</span><br><span class="line">                     completion:(YYWebImageCompletionBlock)completion NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">- (instancetype)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">+ (instancetype)new UNAVAILABLE_ATTRIBUTE;</span><br></pre></td></tr></table></figure></p>
<p><strong>在实现文件中可以看到作者使用了自旋锁在保证了多线程同时访问本类的时候不会导致数据出错的同时性能高效.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static OSSpinLock URLBlacklistLock;//黑名单锁,OSSpinLock(自旋锁)大概是iOS中效率最高的一种锁了</span><br></pre></td></tr></table></figure></p>
<p><strong>在进行关键的操作的时候基本上全部做加锁处理,比如</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  把url添加进黑名单</span><br><span class="line"> *</span><br><span class="line"> *  @param url </span><br><span class="line"> */</span><br><span class="line">static void URLInBlackListAdd(NSURL *url) &#123;</span><br><span class="line">    if (!url || url == (id)[NSNull null]) return;</span><br><span class="line">    URLBlacklistInit();</span><br><span class="line">    OSSpinLockLock(&amp;URLBlacklistLock);</span><br><span class="line">    [URLBlacklist addObject:url];</span><br><span class="line">    OSSpinLockUnlock(&amp;URLBlacklistLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>首先提供给我们两个自定义的线程,都是生成的单例对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">///这里是一个全局的网络请求线程,提供给conllection的代理使用的</span><br><span class="line">+ (NSThread *)_networkThread &#123;</span><br><span class="line">    static NSThread *thread = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        thread = [[NSThread alloc] initWithTarget:self selector:@selector(_networkThreadMain:) object:nil];</span><br><span class="line">        if ([thread respondsToSelector:@selector(setQualityOfService:)]) &#123;</span><br><span class="line">            thread.qualityOfService = NSQualityOfServiceBackground;</span><br><span class="line">        &#125;</span><br><span class="line">        [thread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Global image queue, used for image reading and decoding.</span><br><span class="line">///全局图片线程,用于读取图片解码</span><br><span class="line">+ (dispatch_queue_t)_imageQueue &#123;</span><br><span class="line">#ifdef YYDispatchQueuePool_h</span><br><span class="line">    return YYDispatchQueueGetForQOS(NSQualityOfServiceUtility);</span><br><span class="line">#else</span><br><span class="line">    //最大线程数</span><br><span class="line">    #define MAX_QUEUE_COUNT 16</span><br><span class="line">    static int queueCount;</span><br><span class="line">    static dispatch_queue_t queues[MAX_QUEUE_COUNT];</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    static int32_t counter = 0;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount;</span><br><span class="line">        //如果线程数小于1,返回1,否则返回queueCount或者MAX_QUEUE_COUNT,取决于MAX_QUEUE_COUNT有没有值</span><br><span class="line">        queueCount = queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</span><br><span class="line">        </span><br><span class="line">        if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123;</span><br><span class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</span><br><span class="line">                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, 0);</span><br><span class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.image.decode&quot;, attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</span><br><span class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.image.decode&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    int32_t cur = OSAtomicIncrement32(&amp;counter);</span><br><span class="line">    if (cur &lt; 0) cur = -cur;</span><br><span class="line">    return queues[(cur) % queueCount];</span><br><span class="line">    #undef MAX_QUEUE_COUNT</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>紧接着是请求的构造方法与析构方法,需要注意的是在析构方法里面使用了递归锁<code>NSRecursiveLock</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  构造方法</span><br><span class="line"> *</span><br><span class="line"> *  @param request    请求</span><br><span class="line"> *  @param options    option</span><br><span class="line"> *  @param cache      缓存</span><br><span class="line"> *  @param cacheKey   缓存key</span><br><span class="line"> *  @param progress   进入</span><br><span class="line"> *  @param transform  预处理</span><br><span class="line"> *  @param completion 完成</span><br><span class="line"> *</span><br><span class="line"> *  @return &lt;#return value description#&gt;</span><br><span class="line"> */</span><br><span class="line">- (instancetype)initWithRequest:(NSURLRequest *)request</span><br><span class="line">                        options:(YYWebImageOptions)options</span><br><span class="line">                          cache:(YYImageCache *)cache</span><br><span class="line">                       cacheKey:(NSString *)cacheKey</span><br><span class="line">                       progress:(YYWebImageProgressBlock)progress</span><br><span class="line">                      transform:(YYWebImageTransformBlock)transform</span><br><span class="line">                     completion:(YYWebImageCompletionBlock)completion &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) return nil;</span><br><span class="line">    if (!request) return nil;</span><br><span class="line">    _request = request;</span><br><span class="line">    _options = options;</span><br><span class="line">    _cache = cache;</span><br><span class="line">    //缓存key存在就使用,不存在使用url全路径</span><br><span class="line">    _cacheKey = cacheKey ? cacheKey : request.URL.absoluteString;</span><br><span class="line">    _shouldUseCredentialStorage = YES;</span><br><span class="line">    _progress = progress;</span><br><span class="line">    _transform = transform;</span><br><span class="line">    _completion = completion;</span><br><span class="line">    </span><br><span class="line">    _executing = NO;</span><br><span class="line">    _finished = NO;</span><br><span class="line">    _cancelled = NO;</span><br><span class="line">    _taskID = UIBackgroundTaskInvalid;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  析构方法里面使用了递归锁防止死锁,因为请求可能是有多个的.</span><br><span class="line">    这个方法里面的操作可以保证开启了新的操作队列不会被旧的影响,同时把该清理的状态都归位完毕</span><br><span class="line"> */</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    if (_taskID != UIBackgroundTaskInvalid) &#123;</span><br><span class="line">        [_YYSharedApplication() endBackgroundTask:_taskID];</span><br><span class="line">        _taskID = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //如果正在执行,设置取消为YES,结束为YES</span><br><span class="line">    if ([self isExecuting]) &#123;</span><br><span class="line">        self.cancelled = YES;</span><br><span class="line">        self.finished = YES;</span><br><span class="line">        //如果存在连接,取消它,</span><br><span class="line">        if (_connection) &#123;</span><br><span class="line">            [_connection cancel];</span><br><span class="line">            </span><br><span class="line">            //如果文件URL可达并且option是YYWebImageOptionShowNetworkActivity,那么请求数量-1</span><br><span class="line">            if (![_request.URL isFileURL] &amp;&amp; (_options &amp; YYWebImageOptionShowNetworkActivity)) &#123;</span><br><span class="line">                [YYWebImageManager decrementNetworkActivityCount];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果完成的回调存在,开启一个自动释放池,把参数传空,全置为nil,</span><br><span class="line">        if (_completion) &#123;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                _completion(nil, _request.URL, YYWebImageFromNone, YYWebImageStageCancelled, nil);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在重写的operation的start方法中开启当前operation开始执行,同时在重写operation的<code>start,cancel,execute,finish</code>四个方法的时候,对这些状态进行正确的处理,由于<code>NSOperation</code>的<code>isCancelled</code>方法并不是能够实时监测的,所以在进行任何一个关键操作步骤的时候都要进行检测请求是否被取消掉了,如果取消,直接结束当前所有任务,并对状态值进行正确的赋值.<br>开启请求的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">//开启一个操作,</span><br><span class="line">- (void)_startOperation &#123;</span><br><span class="line">    //如果取消了直接返回,开启一个自动释放池完成以下操作</span><br><span class="line">    if ([self isCancelled]) return;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // get image from cache</span><br><span class="line">        //如果缓存存在,并且option不等于使用NSURLCache,并且option不是刷新缓存,那么直接通过缓存key从缓存中取取图片,同时设置缓存类型为内存缓存</span><br><span class="line">        if (_cache &amp;&amp;</span><br><span class="line">            !(_options &amp; YYWebImageOptionUseNSURLCache) &amp;&amp;</span><br><span class="line">            !(_options &amp; YYWebImageOptionRefreshImageCache)) &#123;</span><br><span class="line">            UIImage *image = [_cache getImageForKey:_cacheKey withType:YYImageCacheTypeMemory];</span><br><span class="line">            if (image) &#123;//取到了图片</span><br><span class="line">                [_lock lock];</span><br><span class="line">            </span><br><span class="line">                if (![self isCancelled]) &#123;//没有取消,</span><br><span class="line">                    //如果已经完成,把图片,图片url,缓存类型,下载结果通过block传递回去</span><br><span class="line">                    if (_completion) _completion(image, _request.URL, YYWebImageFromMemoryCache, YYWebImageStageFinished, nil);</span><br><span class="line">                &#125;</span><br><span class="line">                //调用结束方法</span><br><span class="line">                [self _finish];</span><br><span class="line">                [_lock unlock];</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果下载模式不等于YYWebImageOptionIgnoreDiskCache</span><br><span class="line">            if (!(_options &amp; YYWebImageOptionIgnoreDiskCache)) &#123;</span><br><span class="line">                __weak typeof(self) _self = self;</span><br><span class="line">                //开启一个同步的线程</span><br><span class="line">                dispatch_async([self.class _imageQueue], ^&#123;</span><br><span class="line">                    __strong typeof(_self) self = _self;</span><br><span class="line">                    if (!self || [self isCancelled]) return;//判空处理</span><br><span class="line">                    //直接从磁盘缓存中通过cachekey获取图片</span><br><span class="line">                    UIImage *image = [self.cache getImageForKey:self.cacheKey withType:YYImageCacheTypeDisk];</span><br><span class="line">                    //如果取到了图片</span><br><span class="line">                    if (image) &#123;</span><br><span class="line">                        //先把图片再存进内存缓存</span><br><span class="line">                        [self.cache setImage:image imageData:nil forKey:self.cacheKey withType:YYImageCacheTypeMemory];</span><br><span class="line">                        //在网络线程调用_didReceiveImageFromDiskCache方法</span><br><span class="line">                        [self performSelector:@selector(_didReceiveImageFromDiskCache:) onThread:[self.class _networkThread] withObject:image waitUntilDone:NO];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                    //没有取到图片,就开始在网络线程,开始请求</span><br><span class="line">                        [self performSelector:@selector(_startRequest:) onThread:[self.class _networkThread] withObject:nil waitUntilDone:NO];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //在网络线程立刻开始请求</span><br><span class="line">    [self performSelector:@selector(_startRequest:) onThread:[self.class _networkThread] withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个方法会确保跑在网络请求线程</span><br><span class="line">- (void)_startRequest:(id)object &#123;</span><br><span class="line">    if ([self isCancelled]) return;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //如果模式是YYWebImageOptionIgnoreFailedURL,并且黑名单里面存在这个URL,</span><br><span class="line">        if ((_options &amp; YYWebImageOptionIgnoreFailedURL) &amp;&amp; URLBlackListContains(_request.URL)) &#123;</span><br><span class="line">            //生成一个error</span><br><span class="line">            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:@&#123; NSLocalizedDescriptionKey : @&quot;Failed to load URL, blacklisted.&quot; &#125;];</span><br><span class="line">            [_lock lock];</span><br><span class="line">            //把error以及合适的参数传递给完成的回调,</span><br><span class="line">            if (![self isCancelled]) &#123;</span><br><span class="line">                if (_completion) _completion(nil, _request.URL, YYWebImageFromNone, YYWebImageStageFinished, error);</span><br><span class="line">            &#125;</span><br><span class="line">            [self _finish];</span><br><span class="line">            [_lock unlock];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果url是可达的</span><br><span class="line">        //这步计算文件size的</span><br><span class="line">        if (_request.URL.isFileURL) &#123;</span><br><span class="line">            NSArray *keys = @[NSURLFileSizeKey];</span><br><span class="line">            NSDictionary *attr = [_request.URL resourceValuesForKeys:keys error:nil];</span><br><span class="line">            NSNumber *fileSize = attr[NSURLFileSizeKey];</span><br><span class="line">            _expectedSize = fileSize ? fileSize.unsignedIntegerValue : -1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // request image from web</span><br><span class="line">        //开始下载了,先锁一下</span><br><span class="line">        [_lock lock];</span><br><span class="line">        if (![self isCancelled]) &#123;</span><br><span class="line">            //开启一个connection连接,这里为什么不直接使用delegate而需要通过重写proxy来试下呢?其实我们并不知道NSURLConnection内部delegate是weak/strong还是assign属性,这样做可以保证任何情况下都不会出错</span><br><span class="line">            _connection = [[NSURLConnection alloc] initWithRequest:_request delegate:[_YYWebImageWeakProxy proxyWithTarget:self]];</span><br><span class="line">            //url不可用,并且模式是YYWebImageOptionShowNetworkActivity,给网络请求数量+1</span><br><span class="line">            if (![_request.URL isFileURL] &amp;&amp; (_options &amp; YYWebImageOptionShowNetworkActivity)) &#123;</span><br><span class="line">                [YYWebImageManager incrementNetworkActivityCount];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //结果出来了,解锁</span><br><span class="line">        [_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>取消的方法实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  跑在网络线程上,被另外一个&quot;cancel方法调用&quot;</span><br><span class="line"> */</span><br><span class="line">- (void)_cancelOperation &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        if (_connection) &#123;</span><br><span class="line">            </span><br><span class="line">            //url不可用并且模式是YYWebImageOptionShowNetworkActivity,请求数量-1</span><br><span class="line">            if (![_request.URL isFileURL] &amp;&amp; (_options &amp; YYWebImageOptionShowNetworkActivity)) &#123;</span><br><span class="line">                [YYWebImageManager decrementNetworkActivityCount];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //取消操作并置空</span><br><span class="line">        [_connection cancel];</span><br><span class="line">        _connection = nil;</span><br><span class="line">        //如果实现了完成的block,把相应参数与状态传递回去</span><br><span class="line">        if (_completion) _completion(nil, _request.URL, YYWebImageFromNone, YYWebImageStageCancelled, nil);</span><br><span class="line">        [self _endBackgroundTask];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是通过不同的方式下载得到图片进行的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// runs on network thread</span><br><span class="line">//从磁盘缓存中接受图片</span><br><span class="line">- (void)_didReceiveImageFromDiskCache:(UIImage *)image &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [_lock lock];</span><br><span class="line">        if (![self isCancelled]) &#123;</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                //如果有完成的回调,则传递回去,标记为磁盘缓存</span><br><span class="line">                if (_completion) _completion(image, _request.URL, YYWebImageFromDiskCache, YYWebImageStageFinished, nil);</span><br><span class="line">                [self _finish];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                [self _startRequest:nil];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  从网络下载的图片</span><br><span class="line"> *</span><br><span class="line"> *  @param image &lt;#image description#&gt;</span><br><span class="line"> */</span><br><span class="line">- (void)_didReceiveImageFromWeb:(UIImage *)image &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [_lock lock];</span><br><span class="line">        if (![self isCancelled]) &#123;</span><br><span class="line">            if (_cache) &#123;</span><br><span class="line">                //有图片 或者 模式是刷新缓存的</span><br><span class="line">                if (image || (_options &amp; YYWebImageOptionRefreshImageCache)) &#123;</span><br><span class="line">                    NSData *data = _data;</span><br><span class="line">                    //开一个异步线程,把图片同时存进磁盘与内存缓存</span><br><span class="line">                    dispatch_async([YYWebImageOperation _imageQueue], ^&#123;</span><br><span class="line">                        [_cache setImage:image imageData:data forKey:_cacheKey withType:YYImageCacheTypeAll];</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _data = nil;</span><br><span class="line">            NSError *error = nil;</span><br><span class="line">            //如果没有图片</span><br><span class="line">            if (!image) &#123;</span><br><span class="line">                error = [NSError errorWithDomain:@&quot;com.ibireme.image&quot; code:-1 userInfo:@&#123; NSLocalizedDescriptionKey : @&quot;Web image decode fail.&quot; &#125;];</span><br><span class="line">                //模式是YYWebImageOptionIgnoreFailedURL的话,如果黑名单包括URL,给一个错误警告,否则把它加到黑名单</span><br><span class="line">                if (_options &amp; YYWebImageOptionIgnoreFailedURL) &#123;</span><br><span class="line">                    if (URLBlackListContains(_request.URL)) &#123;</span><br><span class="line">                        error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:@&#123; NSLocalizedDescriptionKey : @&quot;Failed to load URL, blacklisted.&quot; &#125;];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        URLInBlackListAdd(_request.URL);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //把结果与error同时传递给block</span><br><span class="line">            if (_completion) _completion(image, _request.URL, YYWebImageFromRemote, YYWebImageStageFinished, error);</span><br><span class="line">            //结束</span><br><span class="line">            [self _finish];</span><br><span class="line">        &#125;</span><br><span class="line">        [_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>YYWebImage</code>的下载是通过<code>NSURLColleciton</code>来实现的,自然需要在其代理方法里面做接收数据的操作,以下是其代理方法的实现,有点长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection *)connection &#123;</span><br><span class="line">    return _shouldUseCredentialStorage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//即将发送请求验证,验证授权的一大堆乱七八糟东西,暂时不去管</span><br><span class="line">- (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            if (!(_options &amp; YYWebImageOptionAllowInvalidSSLCertificates) &amp;&amp;</span><br><span class="line">                [challenge.sender respondsToSelector:@selector(performDefaultHandlingForAuthenticationChallenge:)]) &#123;</span><br><span class="line">                [challenge.sender performDefaultHandlingForAuthenticationChallenge:challenge];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                [[challenge sender] useCredential:credential forAuthenticationChallenge:challenge];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if ([challenge previousFailureCount] == 0) &#123;</span><br><span class="line">                if (_credential) &#123;</span><br><span class="line">                    [[challenge sender] useCredential:_credential forAuthenticationChallenge:challenge];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    [[challenge sender] continueWithoutCredentialForAuthenticationChallenge:challenge];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                [[challenge sender] continueWithoutCredentialForAuthenticationChallenge:challenge];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//即将缓存请求结果</span><br><span class="line">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse &#123;</span><br><span class="line">    //如果为空,直接返回</span><br><span class="line">    if (!cachedResponse) return cachedResponse;</span><br><span class="line">    //如果模式=YYWebImageOptionUseNSURLCache,返回这个cache相应结果</span><br><span class="line">    if (_options &amp; YYWebImageOptionUseNSURLCache) &#123;</span><br><span class="line">        return cachedResponse;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        //这里就是忽略NSURLCache了,作者有一套自己的缓存机制YYCache</span><br><span class="line">        // ignore NSURLCache</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//请求已经收到相应</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        //先判断是不是NSHTTPURLResponse相应类,是的话,先把状态码记录下来,如果出错,记录一个error</span><br><span class="line">        if ([response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</span><br><span class="line">            NSHTTPURLResponse *httpResponse = (id) response;</span><br><span class="line">            NSInteger statusCode = httpResponse.statusCode;</span><br><span class="line">            if (statusCode &gt;= 400 || statusCode == 304) &#123;</span><br><span class="line">                error = [NSError errorWithDomain:NSURLErrorDomain code:statusCode userInfo:nil];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //有error了,取消连接,调用连接失败的方法同时把error传递过去</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            [_connection cancel];</span><br><span class="line">            [self connection:_connection didFailWithError:error];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //通过length判断有内容,赋值</span><br><span class="line">            if (response.expectedContentLength) &#123;</span><br><span class="line">                _expectedSize = (NSInteger)response.expectedContentLength;</span><br><span class="line">                //没有直接返回-1</span><br><span class="line">                if (_expectedSize &lt; 0) _expectedSize = -1;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //给进度block赋值</span><br><span class="line">            _data = [NSMutableData dataWithCapacity:_expectedSize &gt; 0 ? _expectedSize : 0];</span><br><span class="line">            if (_progress) &#123;</span><br><span class="line">                [_lock lock];</span><br><span class="line">                if ([self isCancelled]) _progress(0, _expectedSize);</span><br><span class="line">                [_lock unlock];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//收到数据回调</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //如果取消了,直接返回</span><br><span class="line">        [_lock lock];</span><br><span class="line">        BOOL canceled = [self isCancelled];</span><br><span class="line">        [_lock unlock];</span><br><span class="line">        if (canceled) return;</span><br><span class="line">        </span><br><span class="line">        //如果data存在,拼接data,把计算data大小传递给进度block</span><br><span class="line">        if (data) [_data appendData:data];</span><br><span class="line">        if (_progress) &#123;</span><br><span class="line">            [_lock lock];</span><br><span class="line">            if (![self isCancelled]) &#123;</span><br><span class="line">                _progress(_data.length, _expectedSize);</span><br><span class="line">            &#125;</span><br><span class="line">            [_lock unlock];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /*--------------------------- progressive ----------------------------*/</span><br><span class="line">        //根据模式判断是否需要返回进度以及是否需要渐进显示</span><br><span class="line">        BOOL progressive = (_options &amp; YYWebImageOptionProgressive) &gt; 0;</span><br><span class="line">        BOOL progressiveBlur = (_options &amp; YYWebImageOptionProgressiveBlur) &gt; 0;</span><br><span class="line">        //如果没有实现了完成block,或者没有任何进度,直接返回</span><br><span class="line">        if (!_completion || !(progressive || progressiveBlur)) return;</span><br><span class="line">        //如果data长度小于一个字节,直接返回</span><br><span class="line">        if (data.length &lt;= 16) return;</span><br><span class="line">        //其实就是length大于1,直接返回</span><br><span class="line">        if (_expectedSize &gt; 0 &amp;&amp; data.length &gt;= _expectedSize * 0.99) return;</span><br><span class="line">        //如果设置了忽略渐进式加载,直接返回</span><br><span class="line">        if (_progressiveIgnored) return;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        NSTimeInterval min = progressiveBlur ? MIN_PROGRESSIVE_BLUR_TIME_INTERVAL : MIN_PROGRESSIVE_TIME_INTERVAL;</span><br><span class="line">        NSTimeInterval now = CACurrentMediaTime();</span><br><span class="line">        if (now - _lastProgressiveDecodeTimestamp &lt; min) return;</span><br><span class="line">        </span><br><span class="line">        //没有解码,初始化一个解码器</span><br><span class="line">        if (!_progressiveDecoder) &#123;</span><br><span class="line">            _progressiveDecoder = [[YYImageDecoder alloc] initWithScale:[UIScreen mainScreen].scale];</span><br><span class="line">        &#125;</span><br><span class="line">        //解码器更新数据</span><br><span class="line">        [_progressiveDecoder updateData:_data final:NO];</span><br><span class="line">        //如果调用取消方法,直接返回</span><br><span class="line">        if ([self isCancelled]) return;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        if (_progressiveDecoder.type == YYImageTypeUnknown ||</span><br><span class="line">            _progressiveDecoder.type == YYImageTypeWebP ||</span><br><span class="line">            _progressiveDecoder.type == YYImageTypeOther) &#123;</span><br><span class="line">            _progressiveDecoder = nil;</span><br><span class="line">            _progressiveIgnored = YES;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //只支持渐进式的JPEG图像和interlanced类型的PNG图像</span><br><span class="line">        if (progressiveBlur) &#123; // only support progressive JPEG and interlaced PNG</span><br><span class="line">            if (_progressiveDecoder.type != YYImageTypeJPEG &amp;&amp;</span><br><span class="line">                _progressiveDecoder.type != YYImageTypePNG) &#123;</span><br><span class="line">                _progressiveDecoder = nil;</span><br><span class="line">                _progressiveIgnored = YES;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (_progressiveDecoder.frameCount == 0) return;</span><br><span class="line">        //不存在渐进显示的话</span><br><span class="line">        if (!progressiveBlur) &#123;</span><br><span class="line">            //从解码中获取图片帧</span><br><span class="line">            YYImageFrame *frame = [_progressiveDecoder frameAtIndex:0 decodeForDisplay:YES];</span><br><span class="line">            if (frame.image) &#123;</span><br><span class="line">                [_lock lock];</span><br><span class="line">                if (![self isCancelled]) &#123;</span><br><span class="line">                    //没有取消,把数据传递给完成block,</span><br><span class="line">                    _completion(frame.image, _request.URL, YYWebImageFromRemote, YYWebImageStageProgress, nil);</span><br><span class="line">                    //给_lastProgressiveDecodeTimestamp赋值</span><br><span class="line">                    _lastProgressiveDecodeTimestamp = now;</span><br><span class="line">                &#125;</span><br><span class="line">                [_lock unlock];</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //解码之后发现是JPEG格式的</span><br><span class="line">            if (_progressiveDecoder.type == YYImageTypeJPEG) &#123;</span><br><span class="line">                //如果表明了不是渐进式加载</span><br><span class="line">                if (!_progressiveDetected) &#123;</span><br><span class="line">                    //从解码中取值</span><br><span class="line">                    NSDictionary *dic = [_progressiveDecoder framePropertiesAtIndex:0];</span><br><span class="line">                    NSDictionary *jpeg = dic[(id)kCGImagePropertyJFIFDictionary];</span><br><span class="line">                    NSNumber *isProg = jpeg[(id)kCGImagePropertyJFIFIsProgressive];</span><br><span class="line">                    if (!isProg.boolValue) &#123;</span><br><span class="line">                        _progressiveIgnored = YES;</span><br><span class="line">                        _progressiveDecoder = nil;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _progressiveDetected = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                //缩放长度为 接收到数据length - _progressiveScanedLength - 4</span><br><span class="line">                NSInteger scanLength = (NSInteger)_data.length - (NSInteger)_progressiveScanedLength - 4;</span><br><span class="line">                //如果&lt;=2,直接返回</span><br><span class="line">                if (scanLength &lt;= 2) return;</span><br><span class="line">                NSRange scanRange = NSMakeRange(_progressiveScanedLength, scanLength);</span><br><span class="line">                NSRange markerRange = [_data rangeOfData:JPEGSOSMarker() options:kNilOptions range:scanRange];</span><br><span class="line">                _progressiveScanedLength = _data.length;</span><br><span class="line">                if (markerRange.location == NSNotFound) return;</span><br><span class="line">                if ([self isCancelled]) return;</span><br><span class="line">                </span><br><span class="line">            &#125; else if (_progressiveDecoder.type == YYImageTypePNG) &#123;//PNG类型图片</span><br><span class="line">                if (!_progressiveDetected) &#123;</span><br><span class="line">                    //从解码中取值,解码,赋值</span><br><span class="line">                    NSDictionary *dic = [_progressiveDecoder framePropertiesAtIndex:0];</span><br><span class="line">                    NSDictionary *png = dic[(id)kCGImagePropertyPNGDictionary];</span><br><span class="line">                    NSNumber *isProg = png[(id)kCGImagePropertyPNGInterlaceType];</span><br><span class="line">                    if (!isProg.boolValue) &#123;</span><br><span class="line">                        _progressiveIgnored = YES;</span><br><span class="line">                        _progressiveDecoder = nil;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _progressiveDetected = YES;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            YYImageFrame *frame = [_progressiveDecoder frameAtIndex:0 decodeForDisplay:YES];</span><br><span class="line">            UIImage *image = frame.image;</span><br><span class="line">            if (!image) return;</span><br><span class="line">            //再次检查是否取消了</span><br><span class="line">            if ([self isCancelled]) return;</span><br><span class="line">            </span><br><span class="line">            //最后一个像素没有填充完毕,以为没有下载成功,返回</span><br><span class="line">            if (!YYCGImageLastPixelFilled(image.CGImage)) return;</span><br><span class="line">            //进度++</span><br><span class="line">            _progressiveDisplayCount++;</span><br><span class="line">            </span><br><span class="line">            CGFloat radius = 32;</span><br><span class="line">            if (_expectedSize &gt; 0) &#123;</span><br><span class="line">                radius *= 1.0 / (3 * _data.length / (CGFloat)_expectedSize + 0.6) - 0.25;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                radius /= (_progressiveDisplayCount);</span><br><span class="line">            &#125;</span><br><span class="line">            //处理图片</span><br><span class="line">            image = [image yy_imageByBlurRadius:radius tintColor:nil tintMode:0 saturation:1 maskImage:nil];</span><br><span class="line">            </span><br><span class="line">            if (image) &#123;</span><br><span class="line">                [_lock lock];</span><br><span class="line">                if (![self isCancelled]) &#123;</span><br><span class="line">                    //图片存在,给完成block赋值</span><br><span class="line">                    _completion(image, _request.URL, YYWebImageFromRemote, YYWebImageStageProgress, nil);</span><br><span class="line">                    //给时间戳赋值</span><br><span class="line">                    _lastProgressiveDecodeTimestamp = now;</span><br><span class="line">                &#125;</span><br><span class="line">                [_lock unlock];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//连接已经结束加载</span><br><span class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [_lock lock];</span><br><span class="line">        _connection = nil;</span><br><span class="line">        if (![self isCancelled]) &#123;</span><br><span class="line">            __weak typeof(self) _self = self;</span><br><span class="line">            //开启一个异步线程</span><br><span class="line">            dispatch_async([self.class _imageQueue], ^&#123;</span><br><span class="line">                __strong typeof(_self) self = _self;</span><br><span class="line">                if (!self) return;</span><br><span class="line">                //通过是否是YYWebImageOptionIgnoreImageDecoding模式判断是否需要解码</span><br><span class="line">                BOOL shouldDecode = (self.options &amp; YYWebImageOptionIgnoreImageDecoding) == 0;</span><br><span class="line">                //通过YYWebImageOptionIgnoreAnimatedImage模式判断是否需要显示动画小姑</span><br><span class="line">                BOOL allowAnimation = (self.options &amp; YYWebImageOptionIgnoreAnimatedImage) == 0;</span><br><span class="line">                UIImage *image;</span><br><span class="line">                BOOL hasAnimation = NO;</span><br><span class="line">                //如果允许动画,通过YYImage这个类加载图片</span><br><span class="line">                if (allowAnimation) &#123;</span><br><span class="line">                    image = [[YYImage alloc] initWithData:self.data scale:[UIScreen mainScreen].scale];</span><br><span class="line">                    //如果需要解码,就解码了0.0</span><br><span class="line">                    if (shouldDecode) image = [image yy_imageByDecoded];</span><br><span class="line">                    //操作动画</span><br><span class="line">                    if ([((YYImage *)image) animatedImageFrameCount] &gt; 1) &#123;</span><br><span class="line">                        hasAnimation = YES;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //不允许动画</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //解码</span><br><span class="line">                    YYImageDecoder *decoder = [YYImageDecoder decoderWithData:self.data scale:[UIScreen mainScreen].scale];</span><br><span class="line">                    //直接取图片</span><br><span class="line">                    image = [decoder frameAtIndex:0 decodeForDisplay:shouldDecode].image;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                /*</span><br><span class="line">                 If the image has animation, save the original image data to disk cache.</span><br><span class="line">                 If the image is not PNG or JPEG, re-encode the image to PNG or JPEG for</span><br><span class="line">                 better decoding performance.</span><br><span class="line">                 */</span><br><span class="line">                //如果是动图,保存原始图片数据到磁盘缓存,如果图片不是PNG或者JPEG格式,把图片转码成PNG或者JPEG格式,此举是为了得到更好的解码表现O.O</span><br><span class="line">                YYImageType imageType = YYImageDetectType((__bridge CFDataRef)self.data);</span><br><span class="line">                switch (imageType) &#123;</span><br><span class="line">                    case YYImageTypeJPEG:</span><br><span class="line">                    case YYImageTypeGIF:</span><br><span class="line">                    case YYImageTypePNG:</span><br><span class="line">                    case YYImageTypeWebP: &#123; // save to disk cache,以上这几种图片村早磁盘</span><br><span class="line">                        if (!hasAnimation) &#123;</span><br><span class="line">                            if (imageType == YYImageTypeGIF ||</span><br><span class="line">                                imageType == YYImageTypeWebP) &#123;</span><br><span class="line">                                //没有动图,并且图片类型是GIF或者WebP,清空数据,给缓存转码</span><br><span class="line">                                self.data = nil; // clear the data, re-encode for disk cache</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; break;</span><br><span class="line">                    default: &#123;</span><br><span class="line">                        self.data = nil; // clear the data, re-encode for disk cache</span><br><span class="line">                    &#125; break;</span><br><span class="line">                &#125;</span><br><span class="line">                if ([self isCancelled]) return;//还要判断,自定义NSOperation真的好麻烦</span><br><span class="line">                </span><br><span class="line">                //如果预处理block在,并且有图片</span><br><span class="line">                if (self.transform &amp;&amp; image) &#123;</span><br><span class="line">                    //传递回调</span><br><span class="line">                    UIImage *newImage = self.transform(image, self.request.URL);</span><br><span class="line">                    //图片错了,清空</span><br><span class="line">                    if (newImage != image) &#123;</span><br><span class="line">                        self.data = nil;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //正确GET</span><br><span class="line">                    image = newImage;</span><br><span class="line">                    if ([self isCancelled]) return;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //调用_didReceiveImageFromWeb方法表明从网络上下载的图片</span><br><span class="line">                [self performSelector:@selector(_didReceiveImageFromWeb:) onThread:[self.class _networkThread] withObject:image waitUntilDone:NO];</span><br><span class="line">            &#125;);</span><br><span class="line">            //如果图片URL不可用,并且模式是YYWebImageOptionShowNetworkActivity,网络请求数量-1</span><br><span class="line">            if (![self.request.URL isFileURL] &amp;&amp; (self.options &amp; YYWebImageOptionShowNetworkActivity)) &#123;</span><br><span class="line">                [YYWebImageManager decrementNetworkActivityCount];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//连接失败</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [_lock lock];</span><br><span class="line">        if (![self isCancelled]) &#123;</span><br><span class="line">            //把失败信息也传递给完成block,因为失败也算完成了</span><br><span class="line">            if (_completion) &#123;</span><br><span class="line">                _completion(nil, _request.URL, YYWebImageFromNone, YYWebImageStageFinished, error);</span><br><span class="line">            &#125;</span><br><span class="line">            _connection = nil;</span><br><span class="line">            _data = nil;</span><br><span class="line">            //如果地址不可用,并且是YYWebImageOptionShowNetworkActivity模式,网络请求数量-1</span><br><span class="line">            if (![_request.URL isFileURL] &amp;&amp; (_options &amp; YYWebImageOptionShowNetworkActivity)) &#123;</span><br><span class="line">                [YYWebImageManager decrementNetworkActivityCount];</span><br><span class="line">            &#125;</span><br><span class="line">            //手动调一下结束方法</span><br><span class="line">            [self _finish];</span><br><span class="line">            </span><br><span class="line">            //如果模式是忽略错误URL:YYWebImageOptionIgnoreFailedURL</span><br><span class="line">            if (_options &amp; YYWebImageOptionIgnoreFailedURL) &#123;</span><br><span class="line">                if (error.code != NSURLErrorNotConnectedToInternet &amp;&amp;</span><br><span class="line">                    error.code != NSURLErrorCancelled &amp;&amp;</span><br><span class="line">                    error.code != NSURLErrorTimedOut &amp;&amp;</span><br><span class="line">                    error.code != NSURLErrorUserCancelledAuthentication) &#123;</span><br><span class="line">                    //加入黑名单</span><br><span class="line">                    URLInBlackListAdd(_request.URL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最下面是重写的NSOperation的状态值方法,主要看start跟cancel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  开始这个NSOperation</span><br><span class="line"> */</span><br><span class="line">- (void)start &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [_lock lock];</span><br><span class="line">        self.started = YES;//赋值开始标记为YES</span><br><span class="line">        if ([self isCancelled]) &#123;</span><br><span class="line">            //如果这时候被取消了,调用取消方法</span><br><span class="line">            [self performSelector:@selector(_cancelOperation) onThread:[[self class] _networkThread] withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];</span><br><span class="line">            self.finished = YES;//标记结束位YES</span><br><span class="line">            //或者如果在准备开始,并且没有结束,并且没有运行中,执行以下操作</span><br><span class="line">        &#125; else if ([self isReady] &amp;&amp; ![self isFinished] &amp;&amp; ![self isExecuting]) &#123;</span><br><span class="line">            //请求失败</span><br><span class="line">            if (!_request) &#123;</span><br><span class="line">                self.finished = YES;//记录结束</span><br><span class="line">                if (_completion) &#123;</span><br><span class="line">                    //把错误信息传递给block</span><br><span class="line">                    NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:@&#123;NSLocalizedDescriptionKey:@&quot;request in nil&quot;&#125;];</span><br><span class="line">                    _completion(nil, _request.URL, YYWebImageFromNone, YYWebImageStageFinished, error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //设置正在执行为YES</span><br><span class="line">                self.executing = YES;</span><br><span class="line">                //调用开始方法</span><br><span class="line">                [self performSelector:@selector(_startOperation) onThread:[[self class] _networkThread] withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];</span><br><span class="line">                //如果模式为YYWebImageOptionAllowBackgroundTask并且在后台,后台下载</span><br><span class="line">                if ((_options &amp; YYWebImageOptionAllowBackgroundTask) &amp;&amp; _YYSharedApplication()) &#123;</span><br><span class="line">                    __weak __typeof__ (self) _self = self;</span><br><span class="line">                    if (_taskID == UIBackgroundTaskInvalid) &#123;</span><br><span class="line">                        _taskID = [_YYSharedApplication() beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">                            __strong __typeof (_self) self = _self;</span><br><span class="line">                            if (self) &#123;</span><br><span class="line">                                [self cancel];</span><br><span class="line">                                self.finished = YES;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取消方法</span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    //先检查是不是取消了,没有取消调用父类取消,设置自己取消为YES</span><br><span class="line">    if (![self isCancelled]) &#123;</span><br><span class="line">        [super cancel];</span><br><span class="line">        self.cancelled = YES;</span><br><span class="line">        //如果正在执行中,设置执行中为NO,调用取消</span><br><span class="line">        if ([self isExecuting]) &#123;</span><br><span class="line">            self.executing = NO;</span><br><span class="line">            [self performSelector:@selector(_cancelOperation) onThread:[[self class] _networkThread] withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];</span><br><span class="line">        &#125;</span><br><span class="line">        //如果已经开始,直接标记结束,不做其他处理</span><br><span class="line">        if (self.started) &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS:<br><a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="noopener">YYWebImage源码地址</a><br><a href="https://github.com/crossPQW/YYWebImage" target="_blank" rel="noopener">我fork下来添加注释的版本github地址</a></p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-读码笔记-YYWebImage源码 (一) - YYWebImageManager" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/12/14/读码笔记-YYWebImage源码 (一) - YYWebImageManager/" class="article-date">
  <time datetime="2015-12-14T08:15:59.000Z" itemprop="datePublished">2015-12-14</time>
</a>
		</span>
		<span class="meta-elements author">黄少华</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2015/12/14/读码笔记-YYWebImage源码 (一) - YYWebImageManager/">读码笔记-YYWebImage源码 (二) -YYWebImageOperation.md</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<blockquote>
<p>不得不说,YYKit系列的横空出世让很多人对国内的开发者都摘下了有色眼镜,原来并非大神全是国外的,自己膜拜之余也想读一下具体的一些实现细节,所以到github上fork了<code>YYWebImage</code>阅读源码并把注释写在response里面,权当笔记.</p>
</blockquote>
<p>第一天,<strong><code>YYWebImageManager</code></strong>类<br>头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">#if __has_include(&lt;YYWebImage/YYWebImage.h&gt;)</span><br><span class="line">#import &lt;YYWebImage/YYImageCache.h&gt;</span><br><span class="line">#else</span><br><span class="line">#import &quot;YYImageCache.h&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@class YYWebImageOperation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/// The options to control image operation.</span><br><span class="line">///控制图片请求的模式</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, YYWebImageOptions) &#123;</span><br><span class="line">    </span><br><span class="line">    /// Show network activity on status bar when download image.</span><br><span class="line">    ///当下载图片的时候会在状态栏显示一个当前网络状况</span><br><span class="line">    YYWebImageOptionShowNetworkActivity = 1 &lt;&lt; 0,</span><br><span class="line">    </span><br><span class="line">    /// Display progressive/interlaced/baseline image during download (same as web browser).</span><br><span class="line">    ///能够像浏览器一样显示一个逐渐显示的图片,有三种方式:换换显示,中间带交叉效果,基于基线显示.这里可以看demo理解三种模式的区别</span><br><span class="line">    YYWebImageOptionProgressive = 1 &lt;&lt; 1,</span><br><span class="line">    </span><br><span class="line">    /// Display blurred progressive JPEG or interlaced PNG image during download.</span><br><span class="line">    /// This will ignore baseline image for better user experience.</span><br><span class="line">    ///下载的时候显示一个模糊的渐渐显示的JPEG图片,或者一个交错显示的PNG图片,具体效果还是看demo</span><br><span class="line">    ///这种模式会忽略baseline这种显示模式来获得更好的用户体验</span><br><span class="line">    YYWebImageOptionProgressiveBlur = 1 &lt;&lt; 2,</span><br><span class="line">    </span><br><span class="line">    /// Use NSURLCache instead of YYImageCache.</span><br><span class="line">    ///使用NSURLCache来代替YYImageCache</span><br><span class="line">    YYWebImageOptionUseNSURLCache = 1 &lt;&lt; 3,</span><br><span class="line">    </span><br><span class="line">    /// Allows untrusted SSL ceriticates.</span><br><span class="line">    ///允许未受信任的SSL证书,PS:基于我的理解以及对比SDWebImage,这种模式一般用户调试过程,不用于生产过程</span><br><span class="line">    YYWebImageOptionAllowInvalidSSLCertificates = 1 &lt;&lt; 4,</span><br><span class="line">    </span><br><span class="line">    /// Allows background task to download image when app is in background.</span><br><span class="line">    ///app进入后台的时候允许后台下载图片</span><br><span class="line">    YYWebImageOptionAllowBackgroundTask = 1 &lt;&lt; 5,</span><br><span class="line">    </span><br><span class="line">    /// Handles cookies stored in NSHTTPCookieStore.</span><br><span class="line">    ///把cookies存储进NSHTTPCookieStore</span><br><span class="line">    YYWebImageOptionHandleCookies = 1 &lt;&lt; 6,</span><br><span class="line">    </span><br><span class="line">    /// Load the image from remote and refresh the image cache.</span><br><span class="line">    ///从远程下载图片并且刷新图片缓存,这种模式可以用于更换了图片内容,但是图片URL不替换</span><br><span class="line">    YYWebImageOptionRefreshImageCache = 1 &lt;&lt; 7,</span><br><span class="line">    </span><br><span class="line">    /// Do not load image from/to disk cache.</span><br><span class="line">    ///不从硬盘缓存加载图片,同时也不会把图片缓存进磁盘</span><br><span class="line">    YYWebImageOptionIgnoreDiskCache = 1 &lt;&lt; 8,</span><br><span class="line">    </span><br><span class="line">    /// Do not change the view&apos;s image before set a new URL to it.</span><br><span class="line">    ///当没有通过一个URL下载到一个新的图片的时候不去修改图片</span><br><span class="line">    YYWebImageOptionIgnorePlaceHolder = 1 &lt;&lt; 9,</span><br><span class="line">    </span><br><span class="line">    /// Ignore image decoding.</span><br><span class="line">    /// This may used for image downloading without display.</span><br><span class="line">    ///忽略图片解码</span><br><span class="line">    ///这种模式可能用于下载的时候并不去显示该图片</span><br><span class="line">    YYWebImageOptionIgnoreImageDecoding = 1 &lt;&lt; 10,</span><br><span class="line">    </span><br><span class="line">    /// Ignore multi-frame image decoding.</span><br><span class="line">    /// This will handle the GIF/APNG/WebP/ICO image as single frame image.</span><br><span class="line">    ///忽略多frame图片解码</span><br><span class="line">    ///这种模式会讲 GIF/APNG/WebP/ICO图片转换为单一frame的图片,开发中如果需求图片固定显示大小,这个模式可能会有用</span><br><span class="line">    YYWebImageOptionIgnoreAnimatedImage = 1 &lt;&lt; 11,</span><br><span class="line">    </span><br><span class="line">    /// Set the image to view with a fade animation.</span><br><span class="line">    /// This will add a &quot;fade&quot; animation on image view&apos;s layer for better user experience.</span><br><span class="line">    ///设置图片的时候带有一个fade的动画效果</span><br><span class="line">    ///会给view&apos;s layer添加一个淡入淡出动画效果来获取更好的用户体验</span><br><span class="line">    YYWebImageOptionSetImageWithFadeAnimation = 1 &lt;&lt; 12,</span><br><span class="line">    </span><br><span class="line">    /// Do not set the image to the view when image fetch complete.</span><br><span class="line">    /// You may set the image manually.</span><br><span class="line">    ///当图片下载完成之前不去设置它</span><br><span class="line">    ///你可以手动设置图片</span><br><span class="line">    YYWebImageOptionAvoidSetImage = 1 &lt;&lt; 13,</span><br><span class="line">    </span><br><span class="line">    /// This flag will add the URL to a blacklist (in memory) when the URL fail to be downloaded,</span><br><span class="line">    /// so the library won&apos;t keep trying.</span><br><span class="line">    ///这种模式会把URL加进黑名单当下载失败的时候,黑名单存储在内存中,所以这种模式不会尝试重复下载</span><br><span class="line">    YYWebImageOptionIgnoreFailedURL = 1 &lt;&lt; 14,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// Indicated where the image came from.</span><br><span class="line">///用来告诉我们图片来源</span><br><span class="line">typedef NS_ENUM(NSUInteger, YYWebImageFromType) &#123;</span><br><span class="line">    </span><br><span class="line">    /// No value.空</span><br><span class="line">    YYWebImageFromNone = 0,</span><br><span class="line">    </span><br><span class="line">    /// Fetched from memory cache immediately.</span><br><span class="line">    /// If you called &quot;setImageWithURL:...&quot; and the image is already in memory,</span><br><span class="line">    /// then you will get this value at the same call.</span><br><span class="line">    ///立刻从内存中查找图片,如果你调用了&quot;setImageWithURL...&quot;并且图片已经存在于内存,你会从相同的回调里面得到这个值</span><br><span class="line">    YYWebImageFromMemoryCacheFast,</span><br><span class="line">    </span><br><span class="line">    /// Fetched from memory cache. ///从内存中来</span><br><span class="line">    YYWebImageFromMemoryCache,</span><br><span class="line">    </span><br><span class="line">    /// Fetched from disk cache. ///从磁盘中来</span><br><span class="line">    YYWebImageFromDiskCache,</span><br><span class="line">    </span><br><span class="line">    /// Fetched from remote (web or file path).///从远程下载的,可以是web或者一个路径</span><br><span class="line">    YYWebImageFromRemote,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// Indicated image fetch complete stage.</span><br><span class="line">///用来告诉我们图片下载的完成度的</span><br><span class="line">typedef NS_ENUM(NSInteger, YYWebImageStage) &#123;</span><br><span class="line">    </span><br><span class="line">    /// Incomplete, progressive image.///未完成,带进度的image</span><br><span class="line">    YYWebImageStageProgress  = -1,</span><br><span class="line">    </span><br><span class="line">    /// Cancelled.///已经取消了</span><br><span class="line">    YYWebImageStageCancelled = 0,</span><br><span class="line">    </span><br><span class="line">    /// Finished (succeed or failed).///已经结束,可能是成功或者失败</span><br><span class="line">    YYWebImageStageFinished  = 1,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The block invoked in remote image fetch progress.</span><br><span class="line"> </span><br><span class="line"> @param receivedSize Current received size in bytes.</span><br><span class="line"> @param expectedSize Expected total size in bytes (-1 means unknown).</span><br><span class="line"> */</span><br><span class="line">///从远程下载完成过程的回调,参数receivedSize是已经下载的大小,expectedSize是总共大小,因此可以通过receivedSize/expectedSize获得progress,如果expectedSize = -1代表着不知道一共有多大</span><br><span class="line">typedef void(^YYWebImageProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The block invoked before remote image fetch finished to do additional image process.</span><br><span class="line"> </span><br><span class="line"> @discussion This block will be invoked before `YYWebImageCompletionBlock` to give</span><br><span class="line"> you a chance to do additional image process (such as resize or crop). If there&apos;s</span><br><span class="line"> no need to transform the image, just return the `image` parameter.</span><br><span class="line"> </span><br><span class="line"> @example You can clip the image, blur it and add rounded corners with these code:</span><br><span class="line">    ^(UIImage *image, NSURL *url) &#123;</span><br><span class="line">        // Maybe you need to create an @autoreleasepool to limit memory cost.</span><br><span class="line">        image = [image yy_imageByResizeToSize:CGSizeMake(100, 100) contentMode:UIViewContentModeScaleAspectFill];</span><br><span class="line">        image = [image yy_imageByBlurRadius:20 tintColor:nil tintMode:kCGBlendModeNormal saturation:1.2 maskImage:nil];</span><br><span class="line">        image = [image yy_imageByRoundCornerRadius:5];</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> @param image The image fetched from url.</span><br><span class="line"> @param url   The image url (remote or local file path).</span><br><span class="line"> @return The transformed image.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> 图片从远程下载完成之前会执行这个block,用来执行一些额外的操作</span><br><span class="line"> @discussion 当&apos;YYWebImageCompletionBlock&apos;这个完成度额回调在下载完成之前会执行这个回调用来给你一个机会做一些额外的处理,比如用来修改图片尺寸等.如果这里不需要对图片进行transform处理,只会返回image这一个参数</span><br><span class="line"> @example 你可以裁剪/模糊图片,或者添加一些边角通过以下代码:</span><br><span class="line"> ^(UIImage *image, NSURL *url)&#123;</span><br><span class="line"> //可能你需要创建一个 @autoreleasepool来限制内存开销</span><br><span class="line"> image = [image yy_imageByResizeToSize:CGSizeMake(100, 100) contentMode:UIViewContentModeScaleAspectFill];</span><br><span class="line"> image = [image yy_imageByBlurRadius:20 tintColor:nil tintMode:kCGBlendModeNormal saturation:1.2 maskImage:nil];</span><br><span class="line"> image = [image yy_imageByRoundCornerRadius:5];</span><br><span class="line"> return image;</span><br><span class="line"> &#125;</span><br><span class="line"> */</span><br><span class="line">typedef UIImage *(^YYWebImageTransformBlock)(UIImage *image, NSURL *url);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The block invoked when image fetch finished or cancelled.</span><br><span class="line"> </span><br><span class="line"> @param image       The image.</span><br><span class="line"> @param url         The image url (remote or local file path).</span><br><span class="line"> @param from        Where the image came from.</span><br><span class="line"> @param error       Error during image fetching.</span><br><span class="line"> @param finished    If the operation is cancelled, this value is NO, otherwise YES.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> 这个block会在当图片下载完成或者取消的时候调用</span><br><span class="line"> </span><br><span class="line"> @param image       The image.</span><br><span class="line"> @param url         图片url,远程或者本地路径</span><br><span class="line"> @param from        图片从哪来,</span><br><span class="line"> @param error       图片下载中的错误</span><br><span class="line"> @param finished    如果请求取消掉了,返回NO,其他是YES</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">typedef void (^YYWebImageCompletionBlock)(UIImage *image, NSURL *url, YYWebImageFromType from, YYWebImageStage stage, NSError *error);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> A manager to create and manage web image operation.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  用来创建和管理网络图片任务的管理器,这个类其实就一个作用,管理生成一个YYWebImageOperation实例</span><br><span class="line"> */</span><br><span class="line">@interface YYWebImageManager : NSObject</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Returns global YYWebImageManager instance.</span><br><span class="line"> </span><br><span class="line"> 不需要多解释,返回单例类</span><br><span class="line"> @return YYWebImageManager shared instance.</span><br><span class="line"> */</span><br><span class="line">+ (instancetype)sharedManager;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Creates a manager with an image cache and operation queue.</span><br><span class="line"> </span><br><span class="line"> @param cache  Image cache used by manager (pass nil to avoid image cache).</span><br><span class="line"> @param queue  The operation queue on which image operations are scheduled and run</span><br><span class="line">                (pass nil to make the new operation start immediately without queue).</span><br><span class="line"> @return A new manager.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  生成一个manager,带有缓存与操作队列</span><br><span class="line"> *</span><br><span class="line"> *  @param cache 图片缓存用到的manager,</span><br><span class="line"> *  @param queue 图片请求,调度运行的请求队列</span><br><span class="line"> *</span><br><span class="line"> *  @return 一个新的manager</span><br><span class="line"> */</span><br><span class="line">- (instancetype)initWithCache:(YYImageCache *)cache queue:(NSOperationQueue *)queue NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">- (instancetype)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">+ (instancetype)new UNAVAILABLE_ATTRIBUTE;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Creates and returns a new image operation, the operation will start immediately.</span><br><span class="line"> </span><br><span class="line"> @param url        The image url (remote or local file path).</span><br><span class="line"> @param options    The options to control image operation.</span><br><span class="line"> @param progress   Progress block which will be invoked on background thread (pass nil to avoid).</span><br><span class="line"> @param transform  Transform block which will be invoked on background thread  (pass nil to avoid).</span><br><span class="line"> @param completion Completion block which will be invoked on background thread  (pass nil to avoid).</span><br><span class="line"> @return A new image operation.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  创建返回一个新的operation,这个operation会立刻开始执行</span><br><span class="line"> *</span><br><span class="line"> *  @param url        图片url,可以是远程或者本地路径</span><br><span class="line"> *  @param options    控制下载的option</span><br><span class="line"> *  @param progress   进度block,会在后台线程的时候调用,传空的话会禁用此特性</span><br><span class="line"> *  @param transform  进入后台线程会调用此block,传空禁用此block</span><br><span class="line"> *  @param completion 进入后台线程会调用此block,传空禁用此block</span><br><span class="line"> *</span><br><span class="line"> *  @return 一个新的图片operation</span><br><span class="line"> */</span><br><span class="line">- (YYWebImageOperation *)requestImageWithURL:(NSURL *)url</span><br><span class="line">                                     options:(YYWebImageOptions)options</span><br><span class="line">                                    progress:(YYWebImageProgressBlock)progress</span><br><span class="line">                                   transform:(YYWebImageTransformBlock)transform</span><br><span class="line">                                  completion:(YYWebImageCompletionBlock)completion;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The image cache used by image operation. </span><br><span class="line"> You can set it to nil to avoid image cache.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  图片请求用到的缓存,可以设置为nil来禁用缓存</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong) YYImageCache *cache;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The operation queue on which image operations are scheduled and run.</span><br><span class="line"> You can set it to nil to make the new operation start immediately without queue.</span><br><span class="line"> </span><br><span class="line"> You can use this queue to control maximum number of concurrent operations, to obtain </span><br><span class="line"> the status of the current operations, or to cancel all operations in this manager.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  图片的请求调度运行的队列</span><br><span class="line">    你不通过队列新建一个新的operation的时候可以给这个值置为nil</span><br><span class="line">    </span><br><span class="line">    你可以用这个队列来控制请求的最大值最小值,获得当前操作队列的状态值,或者来取消这个manager中所有的operation</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong) NSOperationQueue *queue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The shared transform block to process image. Default is nil.</span><br><span class="line"> </span><br><span class="line"> When called `requestImageWithURL:options:progress:transform:completion` and</span><br><span class="line"> the `transform` is nil, this block will be used.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  默认值为nil,共享的图片变换的过程,</span><br><span class="line">    当调用`requestImageWithURL:options:progress:transform:completion`并且`transform`为nil时,这个block才有用</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) YYWebImageTransformBlock sharedTransformBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The image request timeout interval in seconds. Default is 15.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  请求超时时间,默认15秒</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) NSTimeInterval timeout;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The username used by NSURLCredential, default is nil.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  NSURLCredential使用的用户名,默认为nil</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong) NSString *username;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The password used by NSURLCredential, default is nil.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  同上,密码,默认为nil</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong) NSString *password;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The image HTTP request header. Default is &quot;Accept:image/webp,image/\*;q=0.8&quot;.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  图片TTTP的请求头,默认是&quot;Accept:image/webp,image/\*;q=0.8&quot;</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSDictionary *headers;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> A block which will be invoked for each image HTTP request to do additional</span><br><span class="line"> HTTP header process. Default is nil.</span><br><span class="line"> </span><br><span class="line"> Use this block to add or remove HTTP header field for a specified URL.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  每个图片http请求做额外的HTTP header操作的时候会调用这个block,默认为nil</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSDictionary *(^headersFilter)(NSURL *url, NSDictionary *header);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> A block which will be invoked for each image operation. Default is nil.</span><br><span class="line"> </span><br><span class="line"> Use this block to provide a custom image cache key for a specified URL.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  每个图片的操作都会调用这个block,默认为nil</span><br><span class="line">    使用这个block能够给URL提供一个自定义的的图片</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy) NSString *(^cacheKeyFilter)(NSURL *url);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Returns the HTTP headers for a specified URL.</span><br><span class="line"> </span><br><span class="line"> @param url A specified URL.</span><br><span class="line"> @return HTTP headers.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  返回URL的HTTP headers</span><br><span class="line"> *</span><br><span class="line"> *  @param url 当前URL</span><br><span class="line"> *</span><br><span class="line"> *  @return http header</span><br><span class="line"> */</span><br><span class="line">- (NSDictionary *)headersForURL:(NSURL *)url;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Returns the cache key for a specified URL.</span><br><span class="line"> </span><br><span class="line"> @param url A specified URL</span><br><span class="line"> @return Cache key used in YYImageCache.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  给URL返回一个cacheKey</span><br><span class="line"> *</span><br><span class="line"> *  @param url 该URL</span><br><span class="line"> *</span><br><span class="line"> *  @return cache key在YYImageCache中有用到</span><br><span class="line"> */</span><br><span class="line">- (NSString *)cacheKeyForURL:(NSURL *)url;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Increments the number of active network requests.</span><br><span class="line"> If this number was zero before incrementing, this will start animating the</span><br><span class="line"> status bar network activity indicator.</span><br><span class="line"> </span><br><span class="line"> This method is thread safe.</span><br><span class="line"> </span><br><span class="line"> This method has no effect in App Extension.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  增加活跃的网络请求数量</span><br><span class="line">    如果在增加前数量为0,那么会在状态来开始有一个网络菊花动画</span><br><span class="line">    该方法是线程安全的</span><br><span class="line">    该方法不会对APP扩展产生影响</span><br><span class="line"> */</span><br><span class="line">+ (void)incrementNetworkActivityCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Decrements the number of active network requests.</span><br><span class="line"> If this number becomes zero after decrementing, this will stop animating the</span><br><span class="line"> status bar network activity indicator.</span><br><span class="line"> </span><br><span class="line"> This method is thread safe.</span><br><span class="line"> </span><br><span class="line"> This method has no effect in App Extension.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  与上面对应,减少活跃的网络请求数量,如果执行完毕之后数量变为0,那么会停止在状态栏的网络指示器动画</span><br><span class="line">    线程安全</span><br><span class="line">    不会影响APP扩展</span><br><span class="line"> */</span><br><span class="line">+ (void)decrementNetworkActivityCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Get current number of active network requests.</span><br><span class="line"> </span><br><span class="line"> This method is thread safe.</span><br><span class="line"> </span><br><span class="line"> This method has no effect in App Extension.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> *  获取当前活跃的网络请求数量</span><br><span class="line"> *  线程安全</span><br><span class="line">    不会影响APP扩展</span><br><span class="line"> *  @return</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)currentNetworkActivityCount;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>实现文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#import &quot;YYWebImageManager.h&quot;</span><br><span class="line">#import &quot;YYImageCache.h&quot;</span><br><span class="line">#import &quot;YYWebImageOperation.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">#define kNetworkIndicatorDelay (1/30.0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/// Returns nil in App Extension.</span><br><span class="line">static UIApplication *_YYSharedApplication() &#123;</span><br><span class="line">    static BOOL isAppExtension = NO;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class cls = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">        if(!cls || ![cls respondsToSelector:@selector(sharedApplication)]) isAppExtension = YES;</span><br><span class="line">        if ([[[NSBundle mainBundle] bundlePath] hasSuffix:@&quot;.appex&quot;]) isAppExtension = YES;</span><br><span class="line">    &#125;);</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;</span><br><span class="line">    return isAppExtension ? nil : [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface _YYWebImageApplicationNetworkIndicatorInfo : NSObject</span><br><span class="line">@property (nonatomic, assign) NSInteger count;</span><br><span class="line">@property (nonatomic, strong) NSTimer *timer;</span><br><span class="line">@end</span><br><span class="line">@implementation _YYWebImageApplicationNetworkIndicatorInfo</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation YYWebImageManager</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  单例类</span><br><span class="line">    在生成的时候会生成一个YYImageCache单例类,会新建一个NSOperationQueue</span><br><span class="line"> *</span><br><span class="line"> *  @return &lt;#return value description#&gt;</span><br><span class="line"> */</span><br><span class="line">+ (instancetype)sharedManager &#123;</span><br><span class="line">    static YYWebImageManager *manager;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        YYImageCache *cache = [YYImageCache sharedCache];</span><br><span class="line">        NSOperationQueue *queue = [NSOperationQueue new];</span><br><span class="line">        if ([queue respondsToSelector:@selector(setQualityOfService:)]) &#123;</span><br><span class="line">            queue.qualityOfService = NSQualityOfServiceBackground;</span><br><span class="line">        &#125;</span><br><span class="line">        manager = [[self alloc] initWithCache:cache queue:queue];</span><br><span class="line">    &#125;);</span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;YYWebImageManager init error&quot; reason:@&quot;Use the designated initializer to init.&quot; userInfo:nil];</span><br><span class="line">    return [self initWithCache:nil queue:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  构造方法,本单例类生成的时候会调用这个方法,传入两个参数,一个缓存,一个队列</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> *  @return &lt;#return value description#&gt;</span><br><span class="line"> */</span><br><span class="line">- (instancetype)initWithCache:(YYImageCache *)cache queue:(NSOperationQueue *)queue&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) return nil;</span><br><span class="line">    //这里很好的遵循了苹果规范,初始化的时候先调用父类,同时初始化了_cache,_queue,_timeout,_header这些属性</span><br><span class="line">    _cache = cache;</span><br><span class="line">    _queue = queue;</span><br><span class="line">    _timeout = 15.0;</span><br><span class="line">    _headers = @&#123; @&quot;Accept&quot; : @&quot;image/webp,image/*;q=0.8&quot; &#125;;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  这里就是具体的下载请求方法了</span><br><span class="line"> *</span><br><span class="line"> *  @param url        图片URL</span><br><span class="line"> *  @param options    加载模式</span><br><span class="line"> *  @param progress   进度</span><br><span class="line"> *  @param transform  下载完成前对图片进行操作形变的block</span><br><span class="line"> *  @param completion 下载完成的block</span><br><span class="line"> *</span><br><span class="line"> *  @return 一个YYWebImageOperation对象</span><br><span class="line"> */</span><br><span class="line">- (YYWebImageOperation *)requestImageWithURL:(NSURL *)url</span><br><span class="line">                                     options:(YYWebImageOptions)options</span><br><span class="line">                                    progress:(YYWebImageProgressBlock)progress</span><br><span class="line">                                   transform:(YYWebImageTransformBlock)transform</span><br><span class="line">                                  completion:(YYWebImageCompletionBlock)completion &#123;</span><br><span class="line">    </span><br><span class="line">    //1.先生成一个request,并且根据传入参数生成request参数</span><br><span class="line">    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">    request.timeoutInterval = _timeout;</span><br><span class="line">    request.HTTPShouldHandleCookies = (options &amp; YYWebImageOptionHandleCookies) != 0;</span><br><span class="line">    //设置请求头</span><br><span class="line">    request.allHTTPHeaderFields = [self headersForURL:url];</span><br><span class="line">    request.HTTPShouldUsePipelining = YES;</span><br><span class="line">    //设置缓存策略,如果加载图片模式存在并且 =YYWebImageOptionUseNSURLCache,使用NSURLRequestUseProtocolCachePolicy策略,否则的话使用NSURLRequestReloadIgnoringLocalCacheData</span><br><span class="line">    //说明:NSURLRequestUseProtocolCachePolicy这个是系统默认的缓存策略,缓存不存在,就去重新服务端拉去,如果存在的话,根据下一步请求的Cache-control字段来进行下一步的操作,比如如果cache-control = must-revalidata,那么还会去询问服务端是否有数据更新,有的话就拉取新数据,没有就返回缓存</span><br><span class="line">    //    NSURLRequestReloadIgnoringLocalCacheData:忽略本地缓存,每次都去请求服务端</span><br><span class="line">    request.cachePolicy = (options &amp; YYWebImageOptionUseNSURLCache) ?</span><br><span class="line">        NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</span><br><span class="line">    </span><br><span class="line">    //2.根据request,option,cache,cacheKey,progress,transformblock,completionblock生成一个YYWebImageOperation对象</span><br><span class="line">    YYWebImageOperation *operation = [[YYWebImageOperation alloc] initWithRequest:request</span><br><span class="line">                                                                          options:options</span><br><span class="line">                                                                            cache:_cache</span><br><span class="line">                                                                         cacheKey:[self cacheKeyForURL:url]</span><br><span class="line">                                                                         progress:progress</span><br><span class="line">                                                                        transform:transform ? transform : _sharedTransformBlock</span><br><span class="line">                                                                       completion:completion];</span><br><span class="line">    //如果有用户名跟密码,operation的credential属性通过系统提供的NSURLCredential类生成</span><br><span class="line">    if (_username &amp;&amp; _password) &#123;</span><br><span class="line">        operation.credential = [NSURLCredential credentialWithUser:_username password:_password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">    &#125;</span><br><span class="line">    //如果operation初始化成功</span><br><span class="line">    if (operation) &#123;</span><br><span class="line">        NSOperationQueue *queue = _queue;</span><br><span class="line">        //并且存在一个queue</span><br><span class="line">        if (queue) &#123;</span><br><span class="line">            //就把生成的operation添加到队列中</span><br><span class="line">            [queue addOperation:operation];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //如果queue不存在,直接开始这个operation</span><br><span class="line">            [operation start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  设置请求头的方法</span><br><span class="line">    可以看出在每一步操作的时候都进行了判空处理,这对于第三方库来说尤为重要,因为不知道使用者会怎么非法的调用你的api</span><br><span class="line"> *</span><br><span class="line"> *  @param url &lt;#url description#&gt;</span><br><span class="line"> *</span><br><span class="line"> *  @return &lt;#return value description#&gt;</span><br><span class="line"> */</span><br><span class="line">- (NSDictionary *)headersForURL:(NSURL *)url &#123;</span><br><span class="line">    if (!url) return nil;</span><br><span class="line">    //如果有_headersFilter这个blcok就把url跟_headers传递回去并且返回这个block,没有的返回_headers</span><br><span class="line">    return _headersFilter ? _headersFilter(url, _headers) : _headers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  生成cackeKey的方法</span><br><span class="line"> *</span><br><span class="line"> *  如果这个cacheKeyFilterblock存在的话,就把url作为参数传入block并且返回这个block,_cacheKeyFilter这个block的返回值为NSString类型,</span><br><span class="line">    反之如果不存在的话直接以url的完整地址作为key</span><br><span class="line"> *</span><br><span class="line"> *  @return cacheKey字符串</span><br><span class="line"> */</span><br><span class="line">- (NSString *)cacheKeyForURL:(NSURL *)url &#123;</span><br><span class="line">    if (!url) return nil;</span><br><span class="line">    return _cacheKeyFilter ? _cacheKeyFilter(url) : url.absoluteString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  以下是网络状态指示器部分的代码</span><br><span class="line"> */</span><br><span class="line">#pragma mark Network Indicator</span><br><span class="line"></span><br><span class="line">+ (_YYWebImageApplicationNetworkIndicatorInfo *)_networkIndicatorInfo &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, @selector(_networkIndicatorInfo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)_setNetworkIndicatorInfo:(_YYWebImageApplicationNetworkIndicatorInfo *)info &#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(_networkIndicatorInfo), info, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  设置网络状态,默认1/30秒会加载一次</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">+ (void)_delaySetActivity:(NSTimer *)timer &#123;</span><br><span class="line">    UIApplication *app = _YYSharedApplication();</span><br><span class="line">    if (!app) return;</span><br><span class="line">    </span><br><span class="line">    NSNumber *visiable = timer.userInfo;</span><br><span class="line">    if (app.networkActivityIndicatorVisible != visiable.boolValue) &#123;</span><br><span class="line">        [app setNetworkActivityIndicatorVisible:visiable.boolValue];</span><br><span class="line">    &#125;</span><br><span class="line">    [timer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  修改数量</span><br><span class="line"> *</span><br><span class="line"> *  @param delta &lt;#delta description#&gt;</span><br><span class="line"> */</span><br><span class="line">+ (void)_changeNetworkActivityCount:(NSInteger)delta &#123;</span><br><span class="line">    if (!_YYSharedApplication()) return;</span><br><span class="line">    </span><br><span class="line">    //定义一个无参无反block,在这个block中操作计数加减</span><br><span class="line">    void (^block)() = ^&#123;</span><br><span class="line">        _YYWebImageApplicationNetworkIndicatorInfo *info = [self _networkIndicatorInfo];</span><br><span class="line">        if (!info) &#123;</span><br><span class="line">            info = [_YYWebImageApplicationNetworkIndicatorInfo new];</span><br><span class="line">            [self _setNetworkIndicatorInfo:info];</span><br><span class="line">        &#125;</span><br><span class="line">        NSInteger count = info.count;</span><br><span class="line">        count += delta;</span><br><span class="line">        info.count = count;</span><br><span class="line">        [info.timer invalidate];//这里紧紧销毁计时器,不置nil会不会销毁失败?</span><br><span class="line">        //每1/30秒执行一次timer,同时把info.count作为参数传递过去,</span><br><span class="line">        //其实这里有个思考,初始化就调度这个NSTimer,设置repeats属性为YES,不需要每次增加网络数量跟减少活跃数量的时候都新初始化这个timer,需要发起的时候调用setFireDate来执行开始与停止定时器工作,岂不是效率更高?</span><br><span class="line">        info.timer = [NSTimer timerWithTimeInterval:kNetworkIndicatorDelay target:self selector:@selector(_delaySetActivity:) userInfo:@(info.count &gt; 0) repeats:NO];</span><br><span class="line">        [[NSRunLoop mainRunLoop] addTimer:info.timer forMode:NSRunLoopCommonModes];</span><br><span class="line">    &#125;;</span><br><span class="line">    //如果在主线程,调用block</span><br><span class="line">    if ([NSThread isMainThread]) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果不在,获取主线程调用block</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  增加活跃网络数量</span><br><span class="line"> */</span><br><span class="line">+ (void)incrementNetworkActivityCount &#123;</span><br><span class="line">    [self _changeNetworkActivityCount:1];</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *  减少</span><br><span class="line"> */</span><br><span class="line">+ (void)decrementNetworkActivityCount &#123;</span><br><span class="line">    [self _changeNetworkActivityCount:-1];</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *  获取当前的活跃请求数量</span><br><span class="line"> *</span><br><span class="line"> *  @return &lt;#return value description#&gt;</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)currentNetworkActivityCount &#123;</span><br><span class="line">    _YYWebImageApplicationNetworkIndicatorInfo *info = [self _networkIndicatorInfo];</span><br><span class="line">    return info.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><del>其实有个疑问在注释里面也写出来了,每次调用<code>+ (void)incrementNetworkActivityCount</code>与<code>+ (void)decrementNetworkActivityCount</code>方法的时候都会新起一个<code>NSTimer</code>,然后再在合适的时间销毁,这样做会不会增加额外的内存开销呢?假如定义一个全局的<code>NSTimer</code>,这样只需要通过<code>setFireDate</code>来控制开启与关闭定时器,岂不更好?</del><br>附上原作者对上述疑问回复<br><img src="/content/images/2015/12/8FDD6A84-B469-4A4D-8B9C-6DAE86547031.png" alt=""></p>
<p><strong>总结</strong>  </p>
<ol>
<li>代码规范. 从注释,到变量名,方法名,枚举的定义,可以看到一个好的开源项目其代码一定是让人读起来赏心悦目的.  </li>
<li>容错处理.因为你不可能知道使用者会如何非法的使用你的api,所以要尽可能做更多的容错处理,最常见的情况就是判空的操作.</li>
<li>注意线程安全,如在<code>+ (void)_changeNetworkActivityCount:(NSInteger)delta</code>中,确保在主线程设置网络指示器的状态.</li>
</ol>
<p>PS:<br><a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="noopener">YYWebImage源码地址</a><br><a href="https://github.com/crossPQW/YYWebImage" target="_blank" rel="noopener">我fork下来添加注释的版本github地址</a></p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-iOS9 快速适配Tips" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/10/16/iOS9 快速适配Tips/" class="article-date">
  <time datetime="2015-10-16T09:23:34.000Z" itemprop="datePublished">2015-10-16</time>
</a>
		</span>
		<span class="meta-elements author">黄少华</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2015/10/16/iOS9 快速适配Tips/">iOS9 快速适配Tips</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<p> Xcode7正式版发布之后,我们团队第一时间进行了升级体验,在确定没有重大bug之后,全体升级Xcode7,世界如此美好~~~<br>但是升级之后还是遇到一些问题,把踩的坑小记一下.  </p>
<p>#####<strong>1.Swift2.0语法更新之后编译不通过</strong>.<br>当初为了学习中,我们项目中某个模块使用swift实现,现在想来这绝逼是最2的事情了,Xcode6以来,每次更新都随着语法的变动,每次看到编译后一堆红色警告都是心烦意乱.对应解决办法不难,修改代码即可.  </p>
<p>#####<strong>2. Bitcode导致编译不通过问题</strong><br>在修改完swift代码之后,编辑报错如下:  </p>
<blockquote>
<p>xxx does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target.  </p>
</blockquote>
<p>Xcode7之后,默认开启Bitcode,但是引用的第三方库不支持啊,AppThinning始终是个美好的愿景啊,暂时可以通过修改<code>Build settings - Build Options - Enable Bitcode 改为NO</code>来解决.  </p>
<p>#####<strong>3.Http request fail</strong><br>iOS9之后默认只支持更安全的HTTPS请求,我们公司暂时不支持HTTPS,我们可以来到info.plist里面添加一项来搞定它.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;</span><br><span class="line">    &lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure></p>
<p>#####<strong>4.新字体导致UI问题</strong><br>新苹方字体个人很喜欢,小字体时观看对眼睛更友好,但是字体间距好像比以前稍微宽了一丢丢,导致UI出现了一丢丢问题,稍微注意一下Label宽度即可.</p>
<p>#####<strong>5.键盘闪现bug</strong><br>应用内无缘无故弹出数字键盘,不知道哪里出问题了,stackoverflow查询之后发现是UIAlertview的问题,需要改为iOS8添加的UIAlertController,<a href="http://huangshaohua.cn/2015/07/24/ios8xin-te-xing-geng-you-ya-de-dan-chuang/" target="_blank" rel="noopener">(iOS8新特性—更优雅的弹窗)</a>,但是由于应用还要支持iOS7,这个问题不了了之,暂且记下.</p>
<p>#####<strong>6. canOpenUrl机制改变导致无法跳转应用</strong><br>iOS9之后处于对用户隐私的考虑,对使用URLScheme跳转做了限制,只需要在info.plist里面<code>LSApplicationQueriesSchemes</code>字段下添加相应的UrlScheme即可正常跳转,白名单上限是50个.<br>常见白名单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> &lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;!-- 微信 URL Scheme 白名单--&gt;</span><br><span class="line">    &lt;string&gt;wechat&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;weixin&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 新浪微博 URL Scheme 白名单--&gt;</span><br><span class="line">    &lt;string&gt;sinaweibohd&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;sinaweibo&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;sinaweibosso&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;weibosdk&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;weibosdk2.5&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- QQ、Qzone URL Scheme 白名单--&gt;</span><br><span class="line">    &lt;string&gt;mqqapi&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqq&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqqOpensdkSSoLogin&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqqconnect&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqqopensdkdataline&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqqopensdkgrouptribeshare&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqqopensdkfriend&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqqopensdkapi&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqqopensdkapiV2&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqqopensdkapiV3&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqzoneopensdk&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;wtloginmqq&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;wtloginmqq2&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqqwpa&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqzone&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqzonev2&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqzoneshare&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;wtloginqzone&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqzonewx&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqzoneopensdkapiV2&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqzoneopensdkapi19&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqzoneopensdkapi&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;mqzoneopensdk&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 支付宝  URL Scheme 白名单--&gt;</span><br><span class="line">    &lt;string&gt;alipay&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;alipayshare&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">&lt;/array&gt;</span><br></pre></td></tr></table></figure></p>
<p><em>PS:哪位仁兄应用里面添加了50个url scheme让我来膜拜一下</em></p>
<p>#####<strong>7.约束leading与training导致的崩溃</strong><br>iOS9以前<code>leading</code>与<code>training</code>基本可以理解为<code>left</code>与<code>right</code>,但是iOS9之后不是了,貌似说增加了某些国家文字支持,是从右往左导致<code>leading</code>与<code>training</code>与<code>left</code>跟right相反了(求证实),我在使用<code>Masonry</code>添加约束的时候已经全用<code>left</code>于<code>right</code>替换.  </p>
<p>#####<strong>8.preferredLanguages导致应用默认为英文的bug</strong><br>哈哈哈哈更新iOS9之后微信跟微博第一时间中枪了…..<br>嗯嗯,严肃.<br>iOS9正式版之后<code>[NSLocale preferredLanguages]</code>返回的当前语言后面加了所在国家后缀,比如中国地<code>zh-Hans</code>变成了<code>zh-Hans-CN</code>,这时候使用返回值的前缀做国际化适配即可.<br>例如<code>if ([currentLanguage hasPrefix:@&quot;zh-Hans&quot;])</code>  </p>
<p>差不多就酱,遇到啥新问题再记下来^_^<br>每次升级都是一堆坑,求一家最低支持iOS9设备的公司Orz……</p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-iOS开发中如何给UITableViewCell添加动画" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/04/14/iOS开发中如何给UITableViewCell添加动画/" class="article-date">
  <time datetime="2015-04-14T14:28:57.000Z" itemprop="datePublished">2015-04-14</time>
</a>
		</span>
		<span class="meta-elements author">黄少华</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2015/04/14/iOS开发中如何给UITableViewCell添加动画/">iOS开发中如何给UITableViewCell添加动画</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<p>UITableView可以说是iOS开发中最常用的控件了,作为一个高逼格的开发者,肯定不想局限于其平淡无奇的滚动效果,这时候我们就想着往上面倒腾出一些比较有意思的特效,下面来看看如何给UITableViewCell加特效!!</p>
<p>我们需要用到的代理方法:</p>
<p>willDisplayCell,顾名思义,在cell即将显示的时候会调用此方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath</span><br></pre></td></tr></table></figure></p>
<p>添加动画操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line"></span><br><span class="line">	SDShotCell *shotCell = (SDShotCell *) cell;</span><br><span class="line"></span><br><span class="line">	CABasicAnimation *scaleAnimation = [CABasicAnimation 	animationWithKeyPath:@&quot;transform&quot;];</span><br><span class="line"></span><br><span class="line">	scaleAnimation.fromValue = [NSValue valueWithCATransform3D:CATransform3DMakeScale(0.8, 0.8, 1)];</span><br><span class="line"></span><br><span class="line">	scaleAnimation.toValue  = [NSValue valueWithCATransform3D:CATransform3DMakeScale(1, 1, 1)];</span><br><span class="line"></span><br><span class="line">	scaleAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];</span><br><span class="line"></span><br><span class="line">	[shotCell.layer addAnimation:scaleAnimation forKey:@&quot;transform&quot;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大功告成,很简单的操作,有兴趣还可以研究更多地动效.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/290760-a352f58c248831e3.gif" alt="271224350203657.gif"></p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
    <article id="post-iOS8新特性---更优雅的弹窗" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/03/05/iOS8新特性---更优雅的弹窗/" class="article-date">
  <time datetime="2015-03-05T03:35:45.000Z" itemprop="datePublished">2015-03-05</time>
</a>
		</span>
		<span class="meta-elements author">黄少华</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/2015/03/05/iOS8新特性---更优雅的弹窗/">iOS8新特性---更优雅的弹窗</a>
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<p>iOS8之后新增了<code>UIAlertController</code>用来取代<code>UIAlertView</code>以及<code>UIActionSheet</code>,它整合了以上两个控件的功能,并且提供了更优雅的创建各种选项的方式.</p>
<p>废话不多说,直接上工程.<br>新建一个工程,在sb里面添加一个Segment用于分别显示<code>UIAlertView</code>以及<code>UIActionSheet</code>,添加一个start按钮用于出发弹窗.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/290760-895daddecff37c3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8A3F4193-1684-41A4-9F44-9CB8EEF4D1D1.png.jpg"><br>点击start触发弹窗,选择alert或者action分别提供两种弹窗模式.<br>不多废话,直接上代码,注意点都在注释里面写清楚了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)start:(UIButton *)sender &#123;</span><br><span class="line">    </span><br><span class="line">    UIAlertControllerStyle style;</span><br><span class="line">    switch (self.seguement.selectedSegmentIndex) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            style = UIAlertControllerStyleAlert;</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case 1:</span><br><span class="line">            style = UIAlertControllerStyleActionSheet;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //初始化alertController</span><br><span class="line">    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;TITLE&quot; message:@&quot;MESSAGE&quot; preferredStyle:style];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //初始化3个alertAction,block里面直接是点击了该选项的回调</span><br><span class="line">    //UIAlertActionStyleDefault默认样式</span><br><span class="line">    UIAlertAction *defaultItem = [UIAlertAction actionWithTitle:@&quot;defaultItem&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) &#123;</span><br><span class="line">        NSLog(@&quot;点击了defaultItem&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    //UIAlertActionStyleCancel取消按钮,无论添加顺序如何,cancle强制显示在最下面</span><br><span class="line">    UIAlertAction *cancaleItem = [UIAlertAction actionWithTitle:@&quot;cancaleItem&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) &#123;</span><br><span class="line">        NSLog(@&quot;点击了cancaleItem&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    //UIAlertActionStyleDestructive警示样式,红色字体</span><br><span class="line">    UIAlertAction *destructiveItem = [UIAlertAction actionWithTitle:@&quot;destructiveItem&quot; style:UIAlertActionStyleDestructive handler:^(UIAlertAction *action) &#123;</span><br><span class="line">        NSLog(@&quot;点击了destructiveItem&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //给alertcontroller添加action事件,会按照添加顺序创建选项</span><br><span class="line">    [alertController addAction:defaultItem];</span><br><span class="line">    [alertController addAction:cancaleItem];</span><br><span class="line">    [alertController addAction:destructiveItem];</span><br><span class="line">    </span><br><span class="line">    //如果是UIAlertControllerStyleAlert样式,还可以添加输入框</span><br><span class="line">    if (style == UIAlertControllerStyleAlert) &#123;</span><br><span class="line">        [alertController addTextFieldWithConfigurationHandler:^(UITextField *textField) &#123;</span><br><span class="line">            textField.font = [UIFont fontWithName:@&quot;AvenirNext-Medium&quot; size:textField.font.pointSize];</span><br><span class="line">            textField.placeholder = @&quot;enjoy coding&quot;;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //弹出alert只需要modal出alertController即可</span><br><span class="line">    [self presentViewController:alertController animated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终展示:<br><img src="http://upload-images.jianshu.io/upload_images/290760-cc88f7f04999355d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/290760-97139e131a2e1079.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.jpg"><br>我们可以看到,使用UIAlertController不需要在以前的alertview的代理方法里面判断各种index执行各种事件了,无益大大的简化了代码,如果iOS以后请果断放弃alertview跟actionsheet吧,当然alertview跟actionsheet还是可以继续使用的.  (求一个不用支持iOS7的公司Orz)<br><a href="https://github.com/crossPQW/UIAlertController/tree/master" target="_blank" rel="noopener">github地址戳这里</a><br>have fun~</p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
</article>


	<hr class="article-devider">



  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  

    </div>
    <div class="mb-search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>
<footer id="footer">
	<h1 class="footer-blog-title">
		<a href="/">crossPQW</a>
	</h1>
	<span class="copyright">
		&copy; 2017 黄少华<br>
		Modify from <a href="http://sanographix.github.io/tumblr/apollo/" target="_blank">Apollo</a> theme, designed by <a href="http://www.sanographix.net/" target="_blank">SANOGRAPHIX.NET</a><br>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	</span>
</footer>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>