<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>读码笔记-YYWebImage源码 (二) -YYWebImageOperation.md | crossPQW</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="YYWebImageOperation是一个自定义operation类,继承自NSOperation,本类读完之后可以很清晰的了解到作者在管理下载队列的时候的想法,以及如何自定义一个operation.  首先看暴露给我们的头文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464">
<meta property="og:type" content="article">
<meta property="og:title" content="读码笔记-YYWebImage源码 (二) -YYWebImageOperation.md">
<meta property="og:url" content="http://yoursite.com/2015/12/15/读码笔记-YYWebImage源码 (二) -YYWebImageOperation/index.html">
<meta property="og:site_name" content="crossPQW">
<meta property="og:description" content="YYWebImageOperation是一个自定义operation类,继承自NSOperation,本类读完之后可以很清晰的了解到作者在管理下载队列的时候的想法,以及如何自定义一个operation.  首先看暴露给我们的头文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464">
<meta property="og:updated_time" content="2017-12-14T15:00:13.754Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读码笔记-YYWebImage源码 (二) -YYWebImageOperation.md">
<meta name="twitter:description" content="YYWebImageOperation是一个自定义operation类,继承自NSOperation,本类读完之后可以很清晰的了解到作者在管理下载队列的时候的想法,以及如何自定义一个operation.  首先看暴露给我们的头文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464">
  
    <link rel="alternative" href="/atom.xml" title="crossPQW" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div class="mobile-nav-panel">
	<i class="icon-reorder icon-large"></i>
</div>
<header id="header">
	<h1 class="blog-title">
		<a href="/">crossPQW</a>
	</h1>
	<nav class="nav">
		<ul>
			<li><a href="/">Home</a></li><li><a href="/archives">Archives</a></li>
			<li><a id="nav-search-btn" class="nav-icon" title="Search"></a></li>
			<li><a href="/atom.xml" id="nav-rss-link" class="nav-icon" title="RSS Feed"></a></li>
		</ul>
	</nav>
	<div id="search-form-wrap">
		<form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
	</div>
</header>
    <div id="main">
      <article id="post-读码笔记-YYWebImage源码 (二) -YYWebImageOperation" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2015/12/15/读码笔记-YYWebImage源码 (二) -YYWebImageOperation/" class="article-date">
  <time datetime="2015-12-15T02:14:59.000Z" itemprop="datePublished">2015-12-15</time>
</a>
		</span>
		<span class="meta-elements author">黄少华</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 class="article-title entry-title" itemprop="name">
      读码笔记-YYWebImage源码 (二) -YYWebImageOperation.md
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<blockquote>
<p><code>YYWebImageOperation</code>是一个自定义operation类,继承自<code>NSOperation</code>,本类读完之后可以很清晰的了解到作者在管理下载队列的时候的想法,以及如何自定义一个operation.</p>
</blockquote>
<p>首先看暴露给我们的头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  YYWebImageOperation 类是NSOperation的子类,用来通过请求获取图片, </span><br><span class="line"> </span><br><span class="line">     @discussion 首先这个operation是异步的,你可以通过把operation添加到一个queue里面来让这个operation生效,或者直接调用&apos;start&apos;方法.当这个operation开始之后,将会做以下事情:</span><br><span class="line">     1.从cache获取 图片,如果取到了,就返回&apos;completion&apos;block,并把图片传入block.</span><br><span class="line">     2.通过图片URL开启一个请求,会通过&apos;progress&apos;参数来通知women图片下载的进度,并且如果在传入option的时候开启了progressive option,会在completionblock里面返回一个渐进显示的图片</span><br><span class="line">     3.通过&apos;transform&apos;block来处理图片</span><br><span class="line">     4.把图片丢到cache中并且在&apos;completion&apos;block返回</span><br><span class="line"> */</span><br><span class="line">@interface YYWebImageOperation : NSOperation</span><br><span class="line"></span><br><span class="line">//图片请求</span><br><span class="line">@property (nonatomic, strong, readonly) NSURLRequest *request;     ///&lt; The image URL request.</span><br><span class="line">//请求的相应结果</span><br><span class="line">@property (nonatomic, strong, readonly) NSURLResponse *response;   ///&lt; The response for request.</span><br><span class="line">//理解为下载图片模式,具体见YYWebImageManager</span><br><span class="line">@property (nonatomic, assign, readonly) YYWebImageOptions options; ///&lt; The operation&apos;s option.</span><br><span class="line">//缓存</span><br><span class="line">@property (nonatomic, strong, readonly) YYImageCache *cache;       ///&lt; The image cache.</span><br><span class="line">//缓存key</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *cacheKey;        ///&lt; The image cache key.</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  这个URL connection 是否是从 存储的认证里面授权查阅出来的.默认值为YES</span><br><span class="line">    @discussion 这个值是NSURLConnectionDelegate的方法-connectionShouldUseCredentialStorage:的返回值</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) BOOL shouldUseCredentialStorage;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  NSURLCredential类</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong) NSURLCredential *credential;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  构造方法,会创建并返回一个新的operation</span><br><span class="line">    你应该调用start方法来开启这个operation,或者把它加到一个operation queue</span><br><span class="line"> *</span><br><span class="line"> *  @param request    图片请求,不可为nil</span><br><span class="line"> *  @param options    下载模式</span><br><span class="line"> *  @param cache      图片缓存,传nil的话就禁用了缓存</span><br><span class="line"> *  @param cacheKey   缓存key,传nil禁用图片缓存</span><br><span class="line"> *  @param progress   下载进度block</span><br><span class="line"> *  @param transform  这个block会在图片下载完成之前调用来让你对图片进行一些预处理,传nil禁用</span><br><span class="line"> *  @param completion 图片下载完成后或者已经取消下载了调用</span><br><span class="line"> *</span><br><span class="line"> *  @return operation实例,出现错误的话就为nil</span><br><span class="line"> */</span><br><span class="line">- (instancetype)initWithRequest:(NSURLRequest *)request</span><br><span class="line">                        options:(YYWebImageOptions)options</span><br><span class="line">                          cache:(YYImageCache *)cache</span><br><span class="line">                       cacheKey:(NSString *)cacheKey</span><br><span class="line">                       progress:(YYWebImageProgressBlock)progress</span><br><span class="line">                      transform:(YYWebImageTransformBlock)transform</span><br><span class="line">                     completion:(YYWebImageCompletionBlock)completion NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">- (instancetype)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">+ (instancetype)new UNAVAILABLE_ATTRIBUTE;</span><br></pre></td></tr></table></figure></p>
<p><strong>在实现文件中可以看到作者使用了自旋锁在保证了多线程同时访问本类的时候不会导致数据出错的同时性能高效.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static OSSpinLock URLBlacklistLock;//黑名单锁,OSSpinLock(自旋锁)大概是iOS中效率最高的一种锁了</span><br></pre></td></tr></table></figure></p>
<p><strong>在进行关键的操作的时候基本上全部做加锁处理,比如</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  把url添加进黑名单</span><br><span class="line"> *</span><br><span class="line"> *  @param url </span><br><span class="line"> */</span><br><span class="line">static void URLInBlackListAdd(NSURL *url) &#123;</span><br><span class="line">    if (!url || url == (id)[NSNull null]) return;</span><br><span class="line">    URLBlacklistInit();</span><br><span class="line">    OSSpinLockLock(&amp;URLBlacklistLock);</span><br><span class="line">    [URLBlacklist addObject:url];</span><br><span class="line">    OSSpinLockUnlock(&amp;URLBlacklistLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>首先提供给我们两个自定义的线程,都是生成的单例对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">///这里是一个全局的网络请求线程,提供给conllection的代理使用的</span><br><span class="line">+ (NSThread *)_networkThread &#123;</span><br><span class="line">    static NSThread *thread = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        thread = [[NSThread alloc] initWithTarget:self selector:@selector(_networkThreadMain:) object:nil];</span><br><span class="line">        if ([thread respondsToSelector:@selector(setQualityOfService:)]) &#123;</span><br><span class="line">            thread.qualityOfService = NSQualityOfServiceBackground;</span><br><span class="line">        &#125;</span><br><span class="line">        [thread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Global image queue, used for image reading and decoding.</span><br><span class="line">///全局图片线程,用于读取图片解码</span><br><span class="line">+ (dispatch_queue_t)_imageQueue &#123;</span><br><span class="line">#ifdef YYDispatchQueuePool_h</span><br><span class="line">    return YYDispatchQueueGetForQOS(NSQualityOfServiceUtility);</span><br><span class="line">#else</span><br><span class="line">    //最大线程数</span><br><span class="line">    #define MAX_QUEUE_COUNT 16</span><br><span class="line">    static int queueCount;</span><br><span class="line">    static dispatch_queue_t queues[MAX_QUEUE_COUNT];</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    static int32_t counter = 0;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount;</span><br><span class="line">        //如果线程数小于1,返回1,否则返回queueCount或者MAX_QUEUE_COUNT,取决于MAX_QUEUE_COUNT有没有值</span><br><span class="line">        queueCount = queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</span><br><span class="line">        </span><br><span class="line">        if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123;</span><br><span class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</span><br><span class="line">                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, 0);</span><br><span class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.image.decode&quot;, attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (NSUInteger i = 0; i &lt; queueCount; i++) &#123;</span><br><span class="line">                queues[i] = dispatch_queue_create(&quot;com.ibireme.image.decode&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">                dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    int32_t cur = OSAtomicIncrement32(&amp;counter);</span><br><span class="line">    if (cur &lt; 0) cur = -cur;</span><br><span class="line">    return queues[(cur) % queueCount];</span><br><span class="line">    #undef MAX_QUEUE_COUNT</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>紧接着是请求的构造方法与析构方法,需要注意的是在析构方法里面使用了递归锁<code>NSRecursiveLock</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  构造方法</span><br><span class="line"> *</span><br><span class="line"> *  @param request    请求</span><br><span class="line"> *  @param options    option</span><br><span class="line"> *  @param cache      缓存</span><br><span class="line"> *  @param cacheKey   缓存key</span><br><span class="line"> *  @param progress   进入</span><br><span class="line"> *  @param transform  预处理</span><br><span class="line"> *  @param completion 完成</span><br><span class="line"> *</span><br><span class="line"> *  @return &lt;#return value description#&gt;</span><br><span class="line"> */</span><br><span class="line">- (instancetype)initWithRequest:(NSURLRequest *)request</span><br><span class="line">                        options:(YYWebImageOptions)options</span><br><span class="line">                          cache:(YYImageCache *)cache</span><br><span class="line">                       cacheKey:(NSString *)cacheKey</span><br><span class="line">                       progress:(YYWebImageProgressBlock)progress</span><br><span class="line">                      transform:(YYWebImageTransformBlock)transform</span><br><span class="line">                     completion:(YYWebImageCompletionBlock)completion &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) return nil;</span><br><span class="line">    if (!request) return nil;</span><br><span class="line">    _request = request;</span><br><span class="line">    _options = options;</span><br><span class="line">    _cache = cache;</span><br><span class="line">    //缓存key存在就使用,不存在使用url全路径</span><br><span class="line">    _cacheKey = cacheKey ? cacheKey : request.URL.absoluteString;</span><br><span class="line">    _shouldUseCredentialStorage = YES;</span><br><span class="line">    _progress = progress;</span><br><span class="line">    _transform = transform;</span><br><span class="line">    _completion = completion;</span><br><span class="line">    </span><br><span class="line">    _executing = NO;</span><br><span class="line">    _finished = NO;</span><br><span class="line">    _cancelled = NO;</span><br><span class="line">    _taskID = UIBackgroundTaskInvalid;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  析构方法里面使用了递归锁防止死锁,因为请求可能是有多个的.</span><br><span class="line">    这个方法里面的操作可以保证开启了新的操作队列不会被旧的影响,同时把该清理的状态都归位完毕</span><br><span class="line"> */</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    if (_taskID != UIBackgroundTaskInvalid) &#123;</span><br><span class="line">        [_YYSharedApplication() endBackgroundTask:_taskID];</span><br><span class="line">        _taskID = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //如果正在执行,设置取消为YES,结束为YES</span><br><span class="line">    if ([self isExecuting]) &#123;</span><br><span class="line">        self.cancelled = YES;</span><br><span class="line">        self.finished = YES;</span><br><span class="line">        //如果存在连接,取消它,</span><br><span class="line">        if (_connection) &#123;</span><br><span class="line">            [_connection cancel];</span><br><span class="line">            </span><br><span class="line">            //如果文件URL可达并且option是YYWebImageOptionShowNetworkActivity,那么请求数量-1</span><br><span class="line">            if (![_request.URL isFileURL] &amp;&amp; (_options &amp; YYWebImageOptionShowNetworkActivity)) &#123;</span><br><span class="line">                [YYWebImageManager decrementNetworkActivityCount];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果完成的回调存在,开启一个自动释放池,把参数传空,全置为nil,</span><br><span class="line">        if (_completion) &#123;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                _completion(nil, _request.URL, YYWebImageFromNone, YYWebImageStageCancelled, nil);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在重写的operation的start方法中开启当前operation开始执行,同时在重写operation的<code>start,cancel,execute,finish</code>四个方法的时候,对这些状态进行正确的处理,由于<code>NSOperation</code>的<code>isCancelled</code>方法并不是能够实时监测的,所以在进行任何一个关键操作步骤的时候都要进行检测请求是否被取消掉了,如果取消,直接结束当前所有任务,并对状态值进行正确的赋值.<br>开启请求的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">//开启一个操作,</span><br><span class="line">- (void)_startOperation &#123;</span><br><span class="line">    //如果取消了直接返回,开启一个自动释放池完成以下操作</span><br><span class="line">    if ([self isCancelled]) return;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // get image from cache</span><br><span class="line">        //如果缓存存在,并且option不等于使用NSURLCache,并且option不是刷新缓存,那么直接通过缓存key从缓存中取取图片,同时设置缓存类型为内存缓存</span><br><span class="line">        if (_cache &amp;&amp;</span><br><span class="line">            !(_options &amp; YYWebImageOptionUseNSURLCache) &amp;&amp;</span><br><span class="line">            !(_options &amp; YYWebImageOptionRefreshImageCache)) &#123;</span><br><span class="line">            UIImage *image = [_cache getImageForKey:_cacheKey withType:YYImageCacheTypeMemory];</span><br><span class="line">            if (image) &#123;//取到了图片</span><br><span class="line">                [_lock lock];</span><br><span class="line">            </span><br><span class="line">                if (![self isCancelled]) &#123;//没有取消,</span><br><span class="line">                    //如果已经完成,把图片,图片url,缓存类型,下载结果通过block传递回去</span><br><span class="line">                    if (_completion) _completion(image, _request.URL, YYWebImageFromMemoryCache, YYWebImageStageFinished, nil);</span><br><span class="line">                &#125;</span><br><span class="line">                //调用结束方法</span><br><span class="line">                [self _finish];</span><br><span class="line">                [_lock unlock];</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果下载模式不等于YYWebImageOptionIgnoreDiskCache</span><br><span class="line">            if (!(_options &amp; YYWebImageOptionIgnoreDiskCache)) &#123;</span><br><span class="line">                __weak typeof(self) _self = self;</span><br><span class="line">                //开启一个同步的线程</span><br><span class="line">                dispatch_async([self.class _imageQueue], ^&#123;</span><br><span class="line">                    __strong typeof(_self) self = _self;</span><br><span class="line">                    if (!self || [self isCancelled]) return;//判空处理</span><br><span class="line">                    //直接从磁盘缓存中通过cachekey获取图片</span><br><span class="line">                    UIImage *image = [self.cache getImageForKey:self.cacheKey withType:YYImageCacheTypeDisk];</span><br><span class="line">                    //如果取到了图片</span><br><span class="line">                    if (image) &#123;</span><br><span class="line">                        //先把图片再存进内存缓存</span><br><span class="line">                        [self.cache setImage:image imageData:nil forKey:self.cacheKey withType:YYImageCacheTypeMemory];</span><br><span class="line">                        //在网络线程调用_didReceiveImageFromDiskCache方法</span><br><span class="line">                        [self performSelector:@selector(_didReceiveImageFromDiskCache:) onThread:[self.class _networkThread] withObject:image waitUntilDone:NO];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                    //没有取到图片,就开始在网络线程,开始请求</span><br><span class="line">                        [self performSelector:@selector(_startRequest:) onThread:[self.class _networkThread] withObject:nil waitUntilDone:NO];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //在网络线程立刻开始请求</span><br><span class="line">    [self performSelector:@selector(_startRequest:) onThread:[self.class _networkThread] withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这个方法会确保跑在网络请求线程</span><br><span class="line">- (void)_startRequest:(id)object &#123;</span><br><span class="line">    if ([self isCancelled]) return;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //如果模式是YYWebImageOptionIgnoreFailedURL,并且黑名单里面存在这个URL,</span><br><span class="line">        if ((_options &amp; YYWebImageOptionIgnoreFailedURL) &amp;&amp; URLBlackListContains(_request.URL)) &#123;</span><br><span class="line">            //生成一个error</span><br><span class="line">            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:@&#123; NSLocalizedDescriptionKey : @&quot;Failed to load URL, blacklisted.&quot; &#125;];</span><br><span class="line">            [_lock lock];</span><br><span class="line">            //把error以及合适的参数传递给完成的回调,</span><br><span class="line">            if (![self isCancelled]) &#123;</span><br><span class="line">                if (_completion) _completion(nil, _request.URL, YYWebImageFromNone, YYWebImageStageFinished, error);</span><br><span class="line">            &#125;</span><br><span class="line">            [self _finish];</span><br><span class="line">            [_lock unlock];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果url是可达的</span><br><span class="line">        //这步计算文件size的</span><br><span class="line">        if (_request.URL.isFileURL) &#123;</span><br><span class="line">            NSArray *keys = @[NSURLFileSizeKey];</span><br><span class="line">            NSDictionary *attr = [_request.URL resourceValuesForKeys:keys error:nil];</span><br><span class="line">            NSNumber *fileSize = attr[NSURLFileSizeKey];</span><br><span class="line">            _expectedSize = fileSize ? fileSize.unsignedIntegerValue : -1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // request image from web</span><br><span class="line">        //开始下载了,先锁一下</span><br><span class="line">        [_lock lock];</span><br><span class="line">        if (![self isCancelled]) &#123;</span><br><span class="line">            //开启一个connection连接,这里为什么不直接使用delegate而需要通过重写proxy来试下呢?其实我们并不知道NSURLConnection内部delegate是weak/strong还是assign属性,这样做可以保证任何情况下都不会出错</span><br><span class="line">            _connection = [[NSURLConnection alloc] initWithRequest:_request delegate:[_YYWebImageWeakProxy proxyWithTarget:self]];</span><br><span class="line">            //url不可用,并且模式是YYWebImageOptionShowNetworkActivity,给网络请求数量+1</span><br><span class="line">            if (![_request.URL isFileURL] &amp;&amp; (_options &amp; YYWebImageOptionShowNetworkActivity)) &#123;</span><br><span class="line">                [YYWebImageManager incrementNetworkActivityCount];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //结果出来了,解锁</span><br><span class="line">        [_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>取消的方法实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  跑在网络线程上,被另外一个&quot;cancel方法调用&quot;</span><br><span class="line"> */</span><br><span class="line">- (void)_cancelOperation &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        if (_connection) &#123;</span><br><span class="line">            </span><br><span class="line">            //url不可用并且模式是YYWebImageOptionShowNetworkActivity,请求数量-1</span><br><span class="line">            if (![_request.URL isFileURL] &amp;&amp; (_options &amp; YYWebImageOptionShowNetworkActivity)) &#123;</span><br><span class="line">                [YYWebImageManager decrementNetworkActivityCount];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //取消操作并置空</span><br><span class="line">        [_connection cancel];</span><br><span class="line">        _connection = nil;</span><br><span class="line">        //如果实现了完成的block,把相应参数与状态传递回去</span><br><span class="line">        if (_completion) _completion(nil, _request.URL, YYWebImageFromNone, YYWebImageStageCancelled, nil);</span><br><span class="line">        [self _endBackgroundTask];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是通过不同的方式下载得到图片进行的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// runs on network thread</span><br><span class="line">//从磁盘缓存中接受图片</span><br><span class="line">- (void)_didReceiveImageFromDiskCache:(UIImage *)image &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [_lock lock];</span><br><span class="line">        if (![self isCancelled]) &#123;</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                //如果有完成的回调,则传递回去,标记为磁盘缓存</span><br><span class="line">                if (_completion) _completion(image, _request.URL, YYWebImageFromDiskCache, YYWebImageStageFinished, nil);</span><br><span class="line">                [self _finish];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                [self _startRequest:nil];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  从网络下载的图片</span><br><span class="line"> *</span><br><span class="line"> *  @param image &lt;#image description#&gt;</span><br><span class="line"> */</span><br><span class="line">- (void)_didReceiveImageFromWeb:(UIImage *)image &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [_lock lock];</span><br><span class="line">        if (![self isCancelled]) &#123;</span><br><span class="line">            if (_cache) &#123;</span><br><span class="line">                //有图片 或者 模式是刷新缓存的</span><br><span class="line">                if (image || (_options &amp; YYWebImageOptionRefreshImageCache)) &#123;</span><br><span class="line">                    NSData *data = _data;</span><br><span class="line">                    //开一个异步线程,把图片同时存进磁盘与内存缓存</span><br><span class="line">                    dispatch_async([YYWebImageOperation _imageQueue], ^&#123;</span><br><span class="line">                        [_cache setImage:image imageData:data forKey:_cacheKey withType:YYImageCacheTypeAll];</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _data = nil;</span><br><span class="line">            NSError *error = nil;</span><br><span class="line">            //如果没有图片</span><br><span class="line">            if (!image) &#123;</span><br><span class="line">                error = [NSError errorWithDomain:@&quot;com.ibireme.image&quot; code:-1 userInfo:@&#123; NSLocalizedDescriptionKey : @&quot;Web image decode fail.&quot; &#125;];</span><br><span class="line">                //模式是YYWebImageOptionIgnoreFailedURL的话,如果黑名单包括URL,给一个错误警告,否则把它加到黑名单</span><br><span class="line">                if (_options &amp; YYWebImageOptionIgnoreFailedURL) &#123;</span><br><span class="line">                    if (URLBlackListContains(_request.URL)) &#123;</span><br><span class="line">                        error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:@&#123; NSLocalizedDescriptionKey : @&quot;Failed to load URL, blacklisted.&quot; &#125;];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        URLInBlackListAdd(_request.URL);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //把结果与error同时传递给block</span><br><span class="line">            if (_completion) _completion(image, _request.URL, YYWebImageFromRemote, YYWebImageStageFinished, error);</span><br><span class="line">            //结束</span><br><span class="line">            [self _finish];</span><br><span class="line">        &#125;</span><br><span class="line">        [_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>YYWebImage</code>的下载是通过<code>NSURLColleciton</code>来实现的,自然需要在其代理方法里面做接收数据的操作,以下是其代理方法的实现,有点长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection *)connection &#123;</span><br><span class="line">    return _shouldUseCredentialStorage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//即将发送请求验证,验证授权的一大堆乱七八糟东西,暂时不去管</span><br><span class="line">- (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            if (!(_options &amp; YYWebImageOptionAllowInvalidSSLCertificates) &amp;&amp;</span><br><span class="line">                [challenge.sender respondsToSelector:@selector(performDefaultHandlingForAuthenticationChallenge:)]) &#123;</span><br><span class="line">                [challenge.sender performDefaultHandlingForAuthenticationChallenge:challenge];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                [[challenge sender] useCredential:credential forAuthenticationChallenge:challenge];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if ([challenge previousFailureCount] == 0) &#123;</span><br><span class="line">                if (_credential) &#123;</span><br><span class="line">                    [[challenge sender] useCredential:_credential forAuthenticationChallenge:challenge];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    [[challenge sender] continueWithoutCredentialForAuthenticationChallenge:challenge];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                [[challenge sender] continueWithoutCredentialForAuthenticationChallenge:challenge];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//即将缓存请求结果</span><br><span class="line">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse &#123;</span><br><span class="line">    //如果为空,直接返回</span><br><span class="line">    if (!cachedResponse) return cachedResponse;</span><br><span class="line">    //如果模式=YYWebImageOptionUseNSURLCache,返回这个cache相应结果</span><br><span class="line">    if (_options &amp; YYWebImageOptionUseNSURLCache) &#123;</span><br><span class="line">        return cachedResponse;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        //这里就是忽略NSURLCache了,作者有一套自己的缓存机制YYCache</span><br><span class="line">        // ignore NSURLCache</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//请求已经收到相应</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        //先判断是不是NSHTTPURLResponse相应类,是的话,先把状态码记录下来,如果出错,记录一个error</span><br><span class="line">        if ([response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</span><br><span class="line">            NSHTTPURLResponse *httpResponse = (id) response;</span><br><span class="line">            NSInteger statusCode = httpResponse.statusCode;</span><br><span class="line">            if (statusCode &gt;= 400 || statusCode == 304) &#123;</span><br><span class="line">                error = [NSError errorWithDomain:NSURLErrorDomain code:statusCode userInfo:nil];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //有error了,取消连接,调用连接失败的方法同时把error传递过去</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            [_connection cancel];</span><br><span class="line">            [self connection:_connection didFailWithError:error];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //通过length判断有内容,赋值</span><br><span class="line">            if (response.expectedContentLength) &#123;</span><br><span class="line">                _expectedSize = (NSInteger)response.expectedContentLength;</span><br><span class="line">                //没有直接返回-1</span><br><span class="line">                if (_expectedSize &lt; 0) _expectedSize = -1;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //给进度block赋值</span><br><span class="line">            _data = [NSMutableData dataWithCapacity:_expectedSize &gt; 0 ? _expectedSize : 0];</span><br><span class="line">            if (_progress) &#123;</span><br><span class="line">                [_lock lock];</span><br><span class="line">                if ([self isCancelled]) _progress(0, _expectedSize);</span><br><span class="line">                [_lock unlock];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//收到数据回调</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //如果取消了,直接返回</span><br><span class="line">        [_lock lock];</span><br><span class="line">        BOOL canceled = [self isCancelled];</span><br><span class="line">        [_lock unlock];</span><br><span class="line">        if (canceled) return;</span><br><span class="line">        </span><br><span class="line">        //如果data存在,拼接data,把计算data大小传递给进度block</span><br><span class="line">        if (data) [_data appendData:data];</span><br><span class="line">        if (_progress) &#123;</span><br><span class="line">            [_lock lock];</span><br><span class="line">            if (![self isCancelled]) &#123;</span><br><span class="line">                _progress(_data.length, _expectedSize);</span><br><span class="line">            &#125;</span><br><span class="line">            [_lock unlock];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /*--------------------------- progressive ----------------------------*/</span><br><span class="line">        //根据模式判断是否需要返回进度以及是否需要渐进显示</span><br><span class="line">        BOOL progressive = (_options &amp; YYWebImageOptionProgressive) &gt; 0;</span><br><span class="line">        BOOL progressiveBlur = (_options &amp; YYWebImageOptionProgressiveBlur) &gt; 0;</span><br><span class="line">        //如果没有实现了完成block,或者没有任何进度,直接返回</span><br><span class="line">        if (!_completion || !(progressive || progressiveBlur)) return;</span><br><span class="line">        //如果data长度小于一个字节,直接返回</span><br><span class="line">        if (data.length &lt;= 16) return;</span><br><span class="line">        //其实就是length大于1,直接返回</span><br><span class="line">        if (_expectedSize &gt; 0 &amp;&amp; data.length &gt;= _expectedSize * 0.99) return;</span><br><span class="line">        //如果设置了忽略渐进式加载,直接返回</span><br><span class="line">        if (_progressiveIgnored) return;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        NSTimeInterval min = progressiveBlur ? MIN_PROGRESSIVE_BLUR_TIME_INTERVAL : MIN_PROGRESSIVE_TIME_INTERVAL;</span><br><span class="line">        NSTimeInterval now = CACurrentMediaTime();</span><br><span class="line">        if (now - _lastProgressiveDecodeTimestamp &lt; min) return;</span><br><span class="line">        </span><br><span class="line">        //没有解码,初始化一个解码器</span><br><span class="line">        if (!_progressiveDecoder) &#123;</span><br><span class="line">            _progressiveDecoder = [[YYImageDecoder alloc] initWithScale:[UIScreen mainScreen].scale];</span><br><span class="line">        &#125;</span><br><span class="line">        //解码器更新数据</span><br><span class="line">        [_progressiveDecoder updateData:_data final:NO];</span><br><span class="line">        //如果调用取消方法,直接返回</span><br><span class="line">        if ([self isCancelled]) return;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        if (_progressiveDecoder.type == YYImageTypeUnknown ||</span><br><span class="line">            _progressiveDecoder.type == YYImageTypeWebP ||</span><br><span class="line">            _progressiveDecoder.type == YYImageTypeOther) &#123;</span><br><span class="line">            _progressiveDecoder = nil;</span><br><span class="line">            _progressiveIgnored = YES;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //只支持渐进式的JPEG图像和interlanced类型的PNG图像</span><br><span class="line">        if (progressiveBlur) &#123; // only support progressive JPEG and interlaced PNG</span><br><span class="line">            if (_progressiveDecoder.type != YYImageTypeJPEG &amp;&amp;</span><br><span class="line">                _progressiveDecoder.type != YYImageTypePNG) &#123;</span><br><span class="line">                _progressiveDecoder = nil;</span><br><span class="line">                _progressiveIgnored = YES;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (_progressiveDecoder.frameCount == 0) return;</span><br><span class="line">        //不存在渐进显示的话</span><br><span class="line">        if (!progressiveBlur) &#123;</span><br><span class="line">            //从解码中获取图片帧</span><br><span class="line">            YYImageFrame *frame = [_progressiveDecoder frameAtIndex:0 decodeForDisplay:YES];</span><br><span class="line">            if (frame.image) &#123;</span><br><span class="line">                [_lock lock];</span><br><span class="line">                if (![self isCancelled]) &#123;</span><br><span class="line">                    //没有取消,把数据传递给完成block,</span><br><span class="line">                    _completion(frame.image, _request.URL, YYWebImageFromRemote, YYWebImageStageProgress, nil);</span><br><span class="line">                    //给_lastProgressiveDecodeTimestamp赋值</span><br><span class="line">                    _lastProgressiveDecodeTimestamp = now;</span><br><span class="line">                &#125;</span><br><span class="line">                [_lock unlock];</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //解码之后发现是JPEG格式的</span><br><span class="line">            if (_progressiveDecoder.type == YYImageTypeJPEG) &#123;</span><br><span class="line">                //如果表明了不是渐进式加载</span><br><span class="line">                if (!_progressiveDetected) &#123;</span><br><span class="line">                    //从解码中取值</span><br><span class="line">                    NSDictionary *dic = [_progressiveDecoder framePropertiesAtIndex:0];</span><br><span class="line">                    NSDictionary *jpeg = dic[(id)kCGImagePropertyJFIFDictionary];</span><br><span class="line">                    NSNumber *isProg = jpeg[(id)kCGImagePropertyJFIFIsProgressive];</span><br><span class="line">                    if (!isProg.boolValue) &#123;</span><br><span class="line">                        _progressiveIgnored = YES;</span><br><span class="line">                        _progressiveDecoder = nil;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _progressiveDetected = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                //缩放长度为 接收到数据length - _progressiveScanedLength - 4</span><br><span class="line">                NSInteger scanLength = (NSInteger)_data.length - (NSInteger)_progressiveScanedLength - 4;</span><br><span class="line">                //如果&lt;=2,直接返回</span><br><span class="line">                if (scanLength &lt;= 2) return;</span><br><span class="line">                NSRange scanRange = NSMakeRange(_progressiveScanedLength, scanLength);</span><br><span class="line">                NSRange markerRange = [_data rangeOfData:JPEGSOSMarker() options:kNilOptions range:scanRange];</span><br><span class="line">                _progressiveScanedLength = _data.length;</span><br><span class="line">                if (markerRange.location == NSNotFound) return;</span><br><span class="line">                if ([self isCancelled]) return;</span><br><span class="line">                </span><br><span class="line">            &#125; else if (_progressiveDecoder.type == YYImageTypePNG) &#123;//PNG类型图片</span><br><span class="line">                if (!_progressiveDetected) &#123;</span><br><span class="line">                    //从解码中取值,解码,赋值</span><br><span class="line">                    NSDictionary *dic = [_progressiveDecoder framePropertiesAtIndex:0];</span><br><span class="line">                    NSDictionary *png = dic[(id)kCGImagePropertyPNGDictionary];</span><br><span class="line">                    NSNumber *isProg = png[(id)kCGImagePropertyPNGInterlaceType];</span><br><span class="line">                    if (!isProg.boolValue) &#123;</span><br><span class="line">                        _progressiveIgnored = YES;</span><br><span class="line">                        _progressiveDecoder = nil;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _progressiveDetected = YES;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            YYImageFrame *frame = [_progressiveDecoder frameAtIndex:0 decodeForDisplay:YES];</span><br><span class="line">            UIImage *image = frame.image;</span><br><span class="line">            if (!image) return;</span><br><span class="line">            //再次检查是否取消了</span><br><span class="line">            if ([self isCancelled]) return;</span><br><span class="line">            </span><br><span class="line">            //最后一个像素没有填充完毕,以为没有下载成功,返回</span><br><span class="line">            if (!YYCGImageLastPixelFilled(image.CGImage)) return;</span><br><span class="line">            //进度++</span><br><span class="line">            _progressiveDisplayCount++;</span><br><span class="line">            </span><br><span class="line">            CGFloat radius = 32;</span><br><span class="line">            if (_expectedSize &gt; 0) &#123;</span><br><span class="line">                radius *= 1.0 / (3 * _data.length / (CGFloat)_expectedSize + 0.6) - 0.25;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                radius /= (_progressiveDisplayCount);</span><br><span class="line">            &#125;</span><br><span class="line">            //处理图片</span><br><span class="line">            image = [image yy_imageByBlurRadius:radius tintColor:nil tintMode:0 saturation:1 maskImage:nil];</span><br><span class="line">            </span><br><span class="line">            if (image) &#123;</span><br><span class="line">                [_lock lock];</span><br><span class="line">                if (![self isCancelled]) &#123;</span><br><span class="line">                    //图片存在,给完成block赋值</span><br><span class="line">                    _completion(image, _request.URL, YYWebImageFromRemote, YYWebImageStageProgress, nil);</span><br><span class="line">                    //给时间戳赋值</span><br><span class="line">                    _lastProgressiveDecodeTimestamp = now;</span><br><span class="line">                &#125;</span><br><span class="line">                [_lock unlock];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//连接已经结束加载</span><br><span class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [_lock lock];</span><br><span class="line">        _connection = nil;</span><br><span class="line">        if (![self isCancelled]) &#123;</span><br><span class="line">            __weak typeof(self) _self = self;</span><br><span class="line">            //开启一个异步线程</span><br><span class="line">            dispatch_async([self.class _imageQueue], ^&#123;</span><br><span class="line">                __strong typeof(_self) self = _self;</span><br><span class="line">                if (!self) return;</span><br><span class="line">                //通过是否是YYWebImageOptionIgnoreImageDecoding模式判断是否需要解码</span><br><span class="line">                BOOL shouldDecode = (self.options &amp; YYWebImageOptionIgnoreImageDecoding) == 0;</span><br><span class="line">                //通过YYWebImageOptionIgnoreAnimatedImage模式判断是否需要显示动画小姑</span><br><span class="line">                BOOL allowAnimation = (self.options &amp; YYWebImageOptionIgnoreAnimatedImage) == 0;</span><br><span class="line">                UIImage *image;</span><br><span class="line">                BOOL hasAnimation = NO;</span><br><span class="line">                //如果允许动画,通过YYImage这个类加载图片</span><br><span class="line">                if (allowAnimation) &#123;</span><br><span class="line">                    image = [[YYImage alloc] initWithData:self.data scale:[UIScreen mainScreen].scale];</span><br><span class="line">                    //如果需要解码,就解码了0.0</span><br><span class="line">                    if (shouldDecode) image = [image yy_imageByDecoded];</span><br><span class="line">                    //操作动画</span><br><span class="line">                    if ([((YYImage *)image) animatedImageFrameCount] &gt; 1) &#123;</span><br><span class="line">                        hasAnimation = YES;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //不允许动画</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //解码</span><br><span class="line">                    YYImageDecoder *decoder = [YYImageDecoder decoderWithData:self.data scale:[UIScreen mainScreen].scale];</span><br><span class="line">                    //直接取图片</span><br><span class="line">                    image = [decoder frameAtIndex:0 decodeForDisplay:shouldDecode].image;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                /*</span><br><span class="line">                 If the image has animation, save the original image data to disk cache.</span><br><span class="line">                 If the image is not PNG or JPEG, re-encode the image to PNG or JPEG for</span><br><span class="line">                 better decoding performance.</span><br><span class="line">                 */</span><br><span class="line">                //如果是动图,保存原始图片数据到磁盘缓存,如果图片不是PNG或者JPEG格式,把图片转码成PNG或者JPEG格式,此举是为了得到更好的解码表现O.O</span><br><span class="line">                YYImageType imageType = YYImageDetectType((__bridge CFDataRef)self.data);</span><br><span class="line">                switch (imageType) &#123;</span><br><span class="line">                    case YYImageTypeJPEG:</span><br><span class="line">                    case YYImageTypeGIF:</span><br><span class="line">                    case YYImageTypePNG:</span><br><span class="line">                    case YYImageTypeWebP: &#123; // save to disk cache,以上这几种图片村早磁盘</span><br><span class="line">                        if (!hasAnimation) &#123;</span><br><span class="line">                            if (imageType == YYImageTypeGIF ||</span><br><span class="line">                                imageType == YYImageTypeWebP) &#123;</span><br><span class="line">                                //没有动图,并且图片类型是GIF或者WebP,清空数据,给缓存转码</span><br><span class="line">                                self.data = nil; // clear the data, re-encode for disk cache</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; break;</span><br><span class="line">                    default: &#123;</span><br><span class="line">                        self.data = nil; // clear the data, re-encode for disk cache</span><br><span class="line">                    &#125; break;</span><br><span class="line">                &#125;</span><br><span class="line">                if ([self isCancelled]) return;//还要判断,自定义NSOperation真的好麻烦</span><br><span class="line">                </span><br><span class="line">                //如果预处理block在,并且有图片</span><br><span class="line">                if (self.transform &amp;&amp; image) &#123;</span><br><span class="line">                    //传递回调</span><br><span class="line">                    UIImage *newImage = self.transform(image, self.request.URL);</span><br><span class="line">                    //图片错了,清空</span><br><span class="line">                    if (newImage != image) &#123;</span><br><span class="line">                        self.data = nil;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //正确GET</span><br><span class="line">                    image = newImage;</span><br><span class="line">                    if ([self isCancelled]) return;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //调用_didReceiveImageFromWeb方法表明从网络上下载的图片</span><br><span class="line">                [self performSelector:@selector(_didReceiveImageFromWeb:) onThread:[self.class _networkThread] withObject:image waitUntilDone:NO];</span><br><span class="line">            &#125;);</span><br><span class="line">            //如果图片URL不可用,并且模式是YYWebImageOptionShowNetworkActivity,网络请求数量-1</span><br><span class="line">            if (![self.request.URL isFileURL] &amp;&amp; (self.options &amp; YYWebImageOptionShowNetworkActivity)) &#123;</span><br><span class="line">                [YYWebImageManager decrementNetworkActivityCount];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//连接失败</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [_lock lock];</span><br><span class="line">        if (![self isCancelled]) &#123;</span><br><span class="line">            //把失败信息也传递给完成block,因为失败也算完成了</span><br><span class="line">            if (_completion) &#123;</span><br><span class="line">                _completion(nil, _request.URL, YYWebImageFromNone, YYWebImageStageFinished, error);</span><br><span class="line">            &#125;</span><br><span class="line">            _connection = nil;</span><br><span class="line">            _data = nil;</span><br><span class="line">            //如果地址不可用,并且是YYWebImageOptionShowNetworkActivity模式,网络请求数量-1</span><br><span class="line">            if (![_request.URL isFileURL] &amp;&amp; (_options &amp; YYWebImageOptionShowNetworkActivity)) &#123;</span><br><span class="line">                [YYWebImageManager decrementNetworkActivityCount];</span><br><span class="line">            &#125;</span><br><span class="line">            //手动调一下结束方法</span><br><span class="line">            [self _finish];</span><br><span class="line">            </span><br><span class="line">            //如果模式是忽略错误URL:YYWebImageOptionIgnoreFailedURL</span><br><span class="line">            if (_options &amp; YYWebImageOptionIgnoreFailedURL) &#123;</span><br><span class="line">                if (error.code != NSURLErrorNotConnectedToInternet &amp;&amp;</span><br><span class="line">                    error.code != NSURLErrorCancelled &amp;&amp;</span><br><span class="line">                    error.code != NSURLErrorTimedOut &amp;&amp;</span><br><span class="line">                    error.code != NSURLErrorUserCancelledAuthentication) &#123;</span><br><span class="line">                    //加入黑名单</span><br><span class="line">                    URLInBlackListAdd(_request.URL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最下面是重写的NSOperation的状态值方法,主要看start跟cancel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  开始这个NSOperation</span><br><span class="line"> */</span><br><span class="line">- (void)start &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [_lock lock];</span><br><span class="line">        self.started = YES;//赋值开始标记为YES</span><br><span class="line">        if ([self isCancelled]) &#123;</span><br><span class="line">            //如果这时候被取消了,调用取消方法</span><br><span class="line">            [self performSelector:@selector(_cancelOperation) onThread:[[self class] _networkThread] withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];</span><br><span class="line">            self.finished = YES;//标记结束位YES</span><br><span class="line">            //或者如果在准备开始,并且没有结束,并且没有运行中,执行以下操作</span><br><span class="line">        &#125; else if ([self isReady] &amp;&amp; ![self isFinished] &amp;&amp; ![self isExecuting]) &#123;</span><br><span class="line">            //请求失败</span><br><span class="line">            if (!_request) &#123;</span><br><span class="line">                self.finished = YES;//记录结束</span><br><span class="line">                if (_completion) &#123;</span><br><span class="line">                    //把错误信息传递给block</span><br><span class="line">                    NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:@&#123;NSLocalizedDescriptionKey:@&quot;request in nil&quot;&#125;];</span><br><span class="line">                    _completion(nil, _request.URL, YYWebImageFromNone, YYWebImageStageFinished, error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //设置正在执行为YES</span><br><span class="line">                self.executing = YES;</span><br><span class="line">                //调用开始方法</span><br><span class="line">                [self performSelector:@selector(_startOperation) onThread:[[self class] _networkThread] withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];</span><br><span class="line">                //如果模式为YYWebImageOptionAllowBackgroundTask并且在后台,后台下载</span><br><span class="line">                if ((_options &amp; YYWebImageOptionAllowBackgroundTask) &amp;&amp; _YYSharedApplication()) &#123;</span><br><span class="line">                    __weak __typeof__ (self) _self = self;</span><br><span class="line">                    if (_taskID == UIBackgroundTaskInvalid) &#123;</span><br><span class="line">                        _taskID = [_YYSharedApplication() beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">                            __strong __typeof (_self) self = _self;</span><br><span class="line">                            if (self) &#123;</span><br><span class="line">                                [self cancel];</span><br><span class="line">                                self.finished = YES;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取消方法</span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    //先检查是不是取消了,没有取消调用父类取消,设置自己取消为YES</span><br><span class="line">    if (![self isCancelled]) &#123;</span><br><span class="line">        [super cancel];</span><br><span class="line">        self.cancelled = YES;</span><br><span class="line">        //如果正在执行中,设置执行中为NO,调用取消</span><br><span class="line">        if ([self isExecuting]) &#123;</span><br><span class="line">            self.executing = NO;</span><br><span class="line">            [self performSelector:@selector(_cancelOperation) onThread:[[self class] _networkThread] withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];</span><br><span class="line">        &#125;</span><br><span class="line">        //如果已经开始,直接标记结束,不做其他处理</span><br><span class="line">        if (self.started) &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS:<br><a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="noopener">YYWebImage源码地址</a><br><a href="https://github.com/crossPQW/YYWebImage" target="_blank" rel="noopener">我fork下来添加注释的版本github地址</a></p>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
			</span>
			<span class="tags">
				
			</span>
		</div>
	</footer>
	
    
<nav id="article-nav">
  
    <a href="/2015/12/16/读码笔记-YYWebImage源码 (三) -YYImageCache/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          读码笔记-YYWebImage源码 (三) -YYImageCache
        
      </div>
    </a>
  
  
    <a href="/2015/12/14/读码笔记-YYWebImage源码 (一) - YYWebImageManager/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          读码笔记-YYWebImage源码 (二) -YYWebImageOperation.md
        
      </div>
    </a>
  
</nav>

  
</article>




    </div>
    <div class="mb-search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>
<footer id="footer">
	<h1 class="footer-blog-title">
		<a href="/">crossPQW</a>
	</h1>
	<span class="copyright">
		&copy; 2017 黄少华<br>
		Modify from <a href="http://sanographix.github.io/tumblr/apollo/" target="_blank">Apollo</a> theme, designed by <a href="http://www.sanographix.net/" target="_blank">SANOGRAPHIX.NET</a><br>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	</span>
</footer>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>